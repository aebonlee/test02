# 24편 | 최적화 - 성능 (Performance)

---

웹사이트를 빠르게 만드는 기술, **성능 최적화**입니다. 사용자 경험을 향상시키고, 검색 순위에도 영향을 미치는 중요한 영역입니다.

---

## 성능의 핵심 지표

### Core Web Vitals

Google이 정의한 웹 성능 핵심 지표입니다.

| 지표 | 의미 | 목표 | 측정 대상 |
|-----|------|------|----------|
| **LCP** | Largest Contentful Paint | < 2.5초 | 가장 큰 콘텐츠 로딩 |
| **FID** | First Input Delay | < 100ms | 첫 상호작용 응답 |
| **CLS** | Cumulative Layout Shift | < 0.1 | 레이아웃 밀림 |

```
[페이지 로드 타임라인]

0s ─── FCP ─── LCP ─── TTI ─── 완료
      │        │        │
      │        │        └─ Time to Interactive (상호작용 가능)
      │        └─ 가장 큰 콘텐츠 로딩
      └─ First Contentful Paint (첫 콘텐츠)
```

---

## 24.1 Language (언어)

### JavaScript 최적화

```javascript
// 나쁜 예: 동기 로딩 (렌더링 차단)
<script src="heavy-script.js"></script>

// 좋은 예: 비동기 로딩
<script src="heavy-script.js" defer></script>
<script src="analytics.js" async></script>
```

**defer vs async:**

| 속성 | 실행 시점 | 순서 보장 | 용도 |
|-----|----------|----------|------|
| `defer` | DOM 파싱 후 | 보장됨 | 일반 스크립트 |
| `async` | 다운로드 완료 즉시 | 보장 안 됨 | 독립 스크립트 |

### CSS 최적화

```css
/* 나쁜 예: 불필요하게 깊은 선택자 */
div.container > ul.list > li.item > a.link { }

/* 좋은 예: 단순한 선택자 */
.link { }
```

**Critical CSS:**
```html
<!-- 중요한 스타일은 인라인으로 -->
<style>
    /* 첫 화면에 필요한 스타일만 */
    .hero { background: #007bff; }
</style>

<!-- 나머지는 비동기 로딩 -->
<link rel="preload" href="styles.css" as="style" onload="this.rel='stylesheet'">
```

---

## 24.2 Runtime (실행 환경)

### Edge Runtime

CDN 엣지에서 실행되어 지연 시간을 최소화합니다.

```typescript
// Edge에서 실행
export const runtime = 'edge';

export async function GET() {
    // 사용자와 가까운 서버에서 응답
    return Response.json({ message: 'Fast!' });
}
```

**Node.js vs Edge:**

| 항목 | Node.js | Edge |
|-----|---------|------|
| 콜드 스타트 | ~500ms | ~50ms |
| 실행 위치 | 특정 리전 | 전 세계 CDN |
| 적합한 용도 | 복잡한 로직 | 간단한 API |

---

## 24.3 Package Manager (패키지 관리자)

### npm (번들 분석)

```bash
# 번들 크기 분석 도구 설치
npm install -D @next/bundle-analyzer
```

**next.config.js:**
```javascript
const withBundleAnalyzer = require('@next/bundle-analyzer')({
    enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
    // Next.js 설정
});
```

**분석 실행:**
```bash
ANALYZE=true npm run build
```

---

## 24.4 Tools (도구)

### Chrome DevTools

**Performance 탭:**
- 페이지 로딩 프로파일링
- JavaScript 실행 시간 분석
- 렌더링 병목 지점 확인

**Network 탭:**
- 리소스 로딩 순서 확인
- 파일 크기 확인
- 캐싱 상태 확인

### PageSpeed Insights

Google의 웹 성능 분석 서비스입니다.

**사용법:**
```
1. https://pagespeed.web.dev/ 접속
2. URL 입력
3. 분석 결과 확인
```

**결과 항목:**
- Core Web Vitals 점수
- 개선 제안
- 진단 정보

**SSALWorks**: PageSpeed Insights + Chrome DevTools를 사용합니다.

---

## 24.5 Library (라이브러리)

### next/image

이미지 자동 최적화 컴포넌트입니다.

```tsx
import Image from 'next/image';

export default function Hero() {
    return (
        <Image
            src="/hero.jpg"
            alt="히어로 이미지"
            width={1200}
            height={600}
            priority          // LCP 이미지
            placeholder="blur" // 블러 효과
        />
    );
}
```

**자동 최적화:**
- WebP/AVIF 변환
- 반응형 이미지 생성
- Lazy loading
- 이미지 크기 최적화

### next/font

폰트 자동 최적화입니다.

```tsx
import { Noto_Sans_KR } from 'next/font/google';

const notoSansKR = Noto_Sans_KR({
    subsets: ['latin'],
    weight: ['400', '700'],
    display: 'swap',  // FOUT 방지
});

export default function RootLayout({ children }) {
    return (
        <html className={notoSansKR.className}>
            <body>{children}</body>
        </html>
    );
}
```

**장점:**
- 폰트 셀프 호스팅
- 레이아웃 시프트 방지
- 서브셋 자동 생성

---

## 24.6 Framework (프레임워크)

### Next.js (성능 기능)

**자동 코드 분할:**
```tsx
// 자동으로 페이지별 번들 생성
// app/page.tsx → 별도 청크
// app/about/page.tsx → 별도 청크
```

**동적 임포트:**
```tsx
import dynamic from 'next/dynamic';

// 무거운 컴포넌트는 동적 로딩
const HeavyChart = dynamic(() => import('./HeavyChart'), {
    loading: () => <p>로딩 중...</p>,
    ssr: false,  // 클라이언트에서만 렌더링
});
```

**정적 생성 (SSG):**
```tsx
// 빌드 시 HTML 미리 생성
export default async function Page() {
    const data = await fetch('https://api.example.com/data');
    return <div>{data}</div>;
}

// 또는 명시적으로
export const dynamic = 'force-static';
```

**캐싱 전략:**
```tsx
// 데이터 캐싱
const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 }  // 1시간 캐시
});

// 캐시 안 함
const realtime = await fetch('https://api.example.com/realtime', {
    cache: 'no-store'
});
```

**SSALWorks**: Next.js의 모든 최적화 기능을 활용합니다.

---

## 24.7 External Service (외부 서비스)

### Vercel (CDN + Edge)

전 세계 CDN으로 빠른 콘텐츠 전송을 제공합니다.

**최적화 기능:**
- 자동 이미지 최적화
- Edge 캐싱
- 압축 (Brotli, Gzip)
- HTTP/2, HTTP/3

**캐싱 설정:**
```javascript
// next.config.js
module.exports = {
    async headers() {
        return [
            {
                source: '/static/:path*',
                headers: [
                    {
                        key: 'Cache-Control',
                        value: 'public, max-age=31536000, immutable',
                    },
                ],
            },
        ];
    },
};
```

### Cloudflare (선택적)

추가 CDN 레이어로 사용할 수 있습니다.

**주요 기능:**
- DDoS 방어
- 이미지 최적화
- 캐싱

**SSALWorks**: Vercel CDN을 기본으로 사용합니다.

---

## 성능 최적화 체크리스트

### 이미지

- [ ] next/image 사용
- [ ] 적절한 크기 지정
- [ ] WebP/AVIF 포맷
- [ ] Lazy loading 적용
- [ ] priority 속성 (LCP 이미지)

### JavaScript

- [ ] 번들 크기 분석
- [ ] 동적 임포트 활용
- [ ] Tree shaking 확인
- [ ] defer/async 사용
- [ ] 불필요한 라이브러리 제거

### 폰트

- [ ] next/font 사용
- [ ] 서브셋 적용
- [ ] display: swap 설정
- [ ] 필요한 굵기만 로드

### 캐싱

- [ ] 정적 리소스 캐싱
- [ ] API 응답 캐싱
- [ ] ISR/SSG 활용
- [ ] CDN 캐싱

### 렌더링

- [ ] SSG 우선 적용
- [ ] SSR은 필요한 경우만
- [ ] 클라이언트 컴포넌트 최소화
- [ ] Suspense 활용

---

## 정리

| 기술 스택 | SSALWorks 선택 |
|----------|---------------|
| Language | JavaScript 최적화, CSS 최적화 |
| Runtime | **Edge Runtime** |
| Package Manager | **npm** (bundle-analyzer) |
| Tools | **Chrome DevTools**, **PageSpeed Insights** |
| Library | **next/image**, **next/font** |
| Framework | **Next.js** (코드 분할, SSG, ISR) |
| External Service | **Vercel (CDN)** |

성능 최적화는 사용자 경험의 핵심입니다. 다음은 **부록: 용어 사전**에서 전체 용어를 정리합니다.

---

**작성일: 2025-12-21 / 글자수: 약 5,300자 / 작성자: Claude / 프롬프터: 써니**
