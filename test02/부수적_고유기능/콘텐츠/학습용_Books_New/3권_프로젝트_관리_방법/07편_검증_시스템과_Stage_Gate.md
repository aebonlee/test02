# 7편 | 검증 시스템과 Stage Gate

---

건물을 지을 때 각 층이 완성되면 감독관이 검사한다. 콘크리트가 제대로 굳었는지, 철근이 규격에 맞는지, 안전 기준을 충족하는지. 검사를 통과해야 다음 층을 올릴 수 있다.

SAL Grid에서는 이것을 Stage Gate라고 부른다. Stage가 끝날 때마다 관문이 있다. 이 관문을 통과해야 다음 Stage로 넘어갈 수 있다. 통과하지 못하면 문제를 해결할 때까지 멈춰 있어야 한다.

왜 이렇게 할까? 문제가 있는 상태에서 다음 단계로 넘어가면 문제가 커지기 때문이다. S2에서 로그인이 제대로 안 되는데 S3에서 AI 연동을 하면? 나중에 로그인 문제를 고칠 때 AI 연동 부분도 다 수정해야 할 수 있다. 일찍 발견하면 작은 수정이지만, 늦게 발견하면 대규모 수정이 된다.

## 1. 세 단계의 검증

SAL Grid에서는 세 단계로 검증이 이루어진다.

**첫 번째는 Task 검증**이다. 각 Task가 끝나면 Verification Agent가 결과물을 검증한다. 코드가 요구사항대로 작성됐는지, 테스트가 통과하는지, 빌드가 되는지 확인한다. 하나의 Task에 대한 미시적인 검증이다.

**두 번째는 Stage Gate 검증**이다. Stage의 모든 Task가 완료되면 Main Agent가 전체를 검증한다. 개별 Task는 다 됐는데 Task들이 서로 잘 연결되는지 확인한다. 로그인 API와 로그인 UI가 제대로 연동되는지, 데이터가 흐름에 맞게 이동하는지. 전체 그림을 보는 거시적인 검증이다.

**세 번째는 PO 승인**이다. AI 검증만으로는 충분하지 않다. 실제 사용자가 써봐야 한다. PO(Product Owner, 프로젝트 책임자)가 직접 기능을 테스트하고 괜찮으면 승인한다. 사람이 직접 확인하는 최종 검증이다.

## 2. Task 검증: 하나씩 확인하기

Task Agent가 작업을 마치면 Verification Agent가 투입된다. 둘은 반드시 다른 Agent다. 작성자가 자기 작업을 검증하면 안 되기 때문이다.

Verification Agent는 verification_instruction을 읽고 검증을 수행한다. 정상 케이스, 엣지 케이스, 에러 케이스를 모두 확인한다. 빌드가 되는지, 테스트가 통과하는지, 다른 Task와 충돌하지 않는지 확인한다.

검증 결과는 22개 속성에 기록된다. test_result에 테스트 통과 여부, build_verification에 빌드 결과, integration_verification에 통합 결과, blockers에 막히는 문제가 있는지. 마지막으로 comprehensive_verification에 최종 판정을 기록한다. "Passed"면 통과, "Failed"면 수정이 필요하다.

만약 검증에 실패하면? Task Agent가 문제를 수정하고 Verification Agent가 다시 검증한다. 통과할 때까지 반복한다.

## 3. Stage Gate: 전체 그림 확인하기

모든 Task가 개별 검증을 통과해도 Stage Gate를 통과하는 것은 아니다. 개별 부품이 다 좋아도 조립하면 안 맞을 수 있다.

Stage의 모든 Task가 완료되면 Main Agent가 Stage Gate 검증을 수행한다. 확인하는 것은 다음과 같다.

모든 Task가 정말 완료됐는가? 하나라도 빠진 것 없는가? 모든 Task의 검증 결과가 "Passed"인가? "Failed"가 섞여 있지 않은가? Blocker가 없는가? 어떤 Task가 막혀 있지 않은가? Task들이 서로 잘 연결되는가? 데이터가 흐름대로 이동하는가?

이 모든 것을 확인하고 Stage Gate 리포트를 작성한다. Task별 완료 현황, 검증 결과 종합, AI의 검증 의견, 그리고 PO가 테스트할 수 있는 가이드를 포함한다.

## 4. PO 테스트 가이드

AI가 아무리 꼼꼼하게 검증해도 사람이 직접 써보는 것과 다르다. AI는 "로그인 버튼 클릭 시 API 호출 성공"을 확인할 수 있지만, "로그인 화면이 직관적인가"는 판단하기 어렵다.

그래서 Stage Gate 검증이 끝나면 PO 테스트 가이드를 제공한다. PO가 어떤 기능을 어떻게 테스트하면 되는지 단계별로 설명한다.

예를 들어 "Google 로그인 테스트"라면: 어떤 파일을 열고, 어떤 버튼을 클릭하고, 무엇을 기대해야 하는지 적는다. 필요한 외부 설정이 있으면 그것도 명시한다. Supabase에 Google Provider가 설정되어 있어야 한다든지.

PO는 이 가이드를 따라 직접 테스트한다. 문제가 없으면 승인하고, 문제가 있으면 거부한다. 거부할 때는 무엇이 문제인지 구체적으로 알려준다.

## 5. 승인과 거부

PO가 승인하면 stage_gate_status가 "approved"로 바뀐다. 다음 Stage로 넘어갈 수 있다.

PO가 거부하면 stage_gate_status가 "rejected"로 바뀌고 사유가 기록된다. "로그인 후 대시보드로 이동하지 않음", "구독 취소 버튼이 작동하지 않음" 같은 구체적인 문제.

거부되면 문제를 해결해야 한다. Task Agent가 수정하고, Verification Agent가 재검증하고, Main Agent가 Stage Gate를 다시 검증하고, PO가 다시 테스트한다. 승인받을 때까지 반복한다.

이게 번거로워 보일 수 있다. 하지만 이 과정을 거치지 않고 문제가 있는 상태로 다음 단계로 넘어가면 더 큰 비용이 든다. 나중에 발견되는 문제는 수정하기가 훨씬 어렵다.

## 6. 왜 AI 검증만으로 안 되는가

AI가 모든 것을 검증할 수 있으면 좋겠지만, 한계가 있다.

첫째, 외부 서비스 연동은 AI가 확인하기 어렵다. Google 로그인이 실제로 되는지는 직접 클릭해봐야 안다. Supabase 설정이 제대로 됐는지, API 키가 유효한지는 실제로 호출해봐야 안다.

둘째, 사용자 경험은 사람이 판단해야 한다. 화면이 직관적인지, 버튼이 찾기 쉬운지, 에러 메시지가 이해하기 쉬운지는 사람의 눈으로 봐야 한다.

셋째, 비즈니스 로직의 의도는 기획자가 확인해야 한다. 코드가 요구사항대로 작동하는지는 AI가 확인할 수 있지만, 요구사항 자체가 맞는지는 비즈니스를 아는 사람이 판단해야 한다.

## 7. 검증 실패 시 대응

검증에서 문제가 발견되면 어떻게 할까?

Task 검증에서 실패하면 해당 Task만 수정한다. 다른 Task에 영향을 주지 않는다.

Stage Gate 검증에서 실패하면 관련된 Task들을 수정한다. Task 간 연동 문제라면 양쪽을 모두 확인해야 할 수 있다.

PO 승인에서 거부되면 문제의 원인을 분석한다. 단순한 버그인지, 요구사항 이해가 잘못됐는지, 설정 문제인지. 원인에 따라 대응이 달라진다.

어느 단계에서든 문제가 발견되면 그 자리에서 해결한다. "나중에 고치자"하고 넘어가면 안 된다. 나중에 고치는 비용이 지금 고치는 비용보다 훨씬 크다.

## 8. 다음 단계

7편에서는 검증 시스템과 Stage Gate를 살펴봤다. Task 검증, Stage Gate 검증, PO 승인의 세 단계를 거쳐야 다음 Stage로 넘어갈 수 있다. 각 단계는 다른 관점에서 품질을 확인한다.

다음 편에서는 SAL Grid 데이터를 Supabase에 저장하고 HTML Viewer로 조회하는 방법을 살펴본다. Grid 정보를 시각적으로 확인하는 도구다.

---

*다음 편: 8편 | Supabase + HTML Viewer*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,600자 / 작성자: Claude / 프롬프터: 써니**
