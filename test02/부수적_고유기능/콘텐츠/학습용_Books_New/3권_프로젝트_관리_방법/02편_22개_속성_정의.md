# 2편 | 22개 속성 정의

---

1편에서 SAL Grid가 3차원 좌표계라는 것을 알았다. S2BA1이라는 Task ID는 "개발 1차 단계, 백엔드 API 영역, 첫 번째 작업"이라는 위치를 알려준다. 하지만 위치만으로는 충분하지 않다. 이 Task가 실제로 무엇을 하는지, 누가 하는지, 어떻게 검증하는지 알아야 한다.

SAL Grid에서는 각 Task에 22개의 속성을 부여한다. 이 속성들이 Task의 모든 정보를 담는다. 마치 사람의 이력서처럼, Task의 정체부터 수행 결과까지 완전한 프로필을 만드는 것이다.

## 1. 왜 22개나 필요한가

처음에는 속성이 이렇게 많지 않았다. Task ID와 이름, 그리고 간단한 설명만 있었다. 하지만 실제로 AI와 협업하면서 문제가 드러났다.

"로그인 기능 완료했습니다"라고 AI가 보고하면, 사람은 이런 질문을 하게 된다. "어떤 파일이 만들어졌지?" "테스트는 했어?" "다른 기능이랑 충돌은 없어?" "빌드는 성공했어?" 매번 이런 질문을 하고 답을 기다리는 것은 비효율적이다.

그래서 Task가 가져야 할 모든 정보를 미리 정의했다. AI가 작업을 마치면 이 22개 칸을 다 채워서 보고한다. 사람은 질문할 필요 없이 한눈에 모든 상황을 파악할 수 있다.

22개 속성은 크게 네 가지 그룹으로 나뉜다.

## 2. 첫 번째 그룹: 식별 정보

처음 다섯 개 속성은 Task의 신분증이다.

**task_id**는 Task의 고유 식별자다. S2BA1처럼 3차원 좌표를 문자로 표현한 것이다. 프로젝트에서 이 ID가 중복되면 안 된다.

**task_name**은 Task의 이름이다. "Google OAuth 로그인 구현"처럼 무엇을 하는 작업인지 짧게 설명한다. ID가 코드라면, 이름은 사람이 읽는 라벨이다.

**stage**, **area**, **level**은 task_id를 분해한 것이다. S2BA1에서 stage는 S2, area는 BA, level은 1이다. 따로 저장하는 이유는 검색과 필터링을 쉽게 하기 위해서다. "S2 단계의 모든 Task"나 "Frontend 영역의 모든 Task"를 찾을 때 유용하다.

## 3. 두 번째 그룹: 실행 정보

여섯 개 속성이 Task의 수행 방법을 정의한다.

**dependencies**는 선행 작업 목록이다. 집을 지을 때 기초 공사를 먼저 해야 벽을 세울 수 있듯이, 어떤 Task들이 먼저 완료되어야 이 Task를 시작할 수 있는지 명시한다. 예를 들어 로그인 API를 만들려면 먼저 사용자 테이블이 있어야 한다. 그래서 로그인 API Task의 dependencies에는 사용자 테이블 Task ID가 들어간다. 의존성 관리는 4편에서 자세히 다룬다.

**task_instruction**은 작업 지시사항이다. AI가 정확히 무엇을 해야 하는지 상세하게 적는다. "로그인 기능 만들어줘"가 아니라 "POST /api/auth/login 엔드포인트를 구현하라. 이메일과 비밀번호를 받아서 JWT 토큰을 반환하라. 비밀번호가 틀리면 401 에러를 반환하라"처럼 구체적으로 작성한다.

**task_agent**는 이 작업을 수행할 AI Agent다. Frontend 작업은 frontend-developer Agent가, Backend API 작업은 backend-developer Agent가 담당한다. 적합한 전문가에게 일을 맡기는 것이다.

**generated_files**는 작업 결과로 만들어진 파일 목록이다. AI가 작업을 마치면 어떤 파일들을 만들었는지 여기에 기록한다. 나중에 "이 Task에서 만든 파일이 뭐지?"라고 찾을 때 유용하다.

**duration**은 소요 시간이다. Task 하나에 얼마나 걸렸는지 기록한다. 주의할 점은 미래 계획에는 시간을 쓰지 않는다는 것이다. "이 Task는 2시간 걸릴 것이다"라고 예측하지 않는다. 하지만 완료된 작업의 시간은 기록한다. 이 데이터가 쌓이면 비슷한 작업에 얼마나 걸리는지 참고할 수 있다.

**build_result**는 빌드 결과다. 코드를 작성한 후 빌드가 성공했는지, 실패했다면 어떤 에러가 났는지 기록한다.

## 4. 세 번째 그룹: 검증 정보

여덟 개 속성이 검증을 담당한다. 이 그룹이 가장 많은 이유는 "만들었다"와 "제대로 만들었다"가 다르기 때문이다.

**verification_instruction**은 검증 지침이다. Task를 어떻게 검증할지 미리 정의한다. 단순히 "테스트하라"가 아니라 "로그인 성공 시 토큰이 반환되는지 확인하라, 잘못된 비밀번호로 로그인 시도했을 때 401 에러가 나는지 확인하라"처럼 구체적인 검증 항목을 나열한다.

**verification_agent**는 검증을 수행할 Agent다. 중요한 원칙이 있다. Task를 만든 Agent와 검증하는 Agent는 반드시 달라야 한다. 자기가 만든 것을 자기가 검증하면 문제를 놓치기 쉽다. 그래서 backend-developer가 만든 코드는 code-reviewer가 검증한다.

**test_result**는 테스트 결과다. 단위 테스트, 통합 테스트, 예외 상황 테스트 등의 결과를 기록한다. "5개 테스트 중 5개 통과"처럼 숫자로 명확하게 표현한다.

**build_verification**은 빌드 검증 결과다. 컴파일 성공 여부, 린트 검사 통과 여부, 배포 성공 여부, 실행 시 에러 여부를 기록한다.

**integration_verification**은 통합 검증 결과다. 이 Task가 다른 Task들과 잘 연결되는지 확인한다. 선행 Task의 결과물을 제대로 사용하는지, 다른 Task와 충돌하지 않는지, 데이터가 정상적으로 흐르는지 검증한다.

**blockers**는 차단 요소다. Task 진행을 막는 문제가 있으면 여기에 기록한다. 선행 Task가 아직 완료되지 않았거나, 외부 API 키가 설정되지 않았거나, 환경 설정에 문제가 있으면 blocker로 표시한다.

**comprehensive_verification**은 종합 검증 결과다. 위의 모든 검증을 종합해서 최종 판정을 내린다. "Passed" 또는 "Failed"로 명확하게 결론짓는다.

**ai_verification_note**는 AI의 검증 의견이다. 검증 과정에서 발견한 특이사항이나 주의점을 자유롭게 기록한다. 예를 들어 "기본 기능은 정상 작동하지만, 동시 접속이 많을 때는 추가 테스트가 필요하다"같은 의견을 남길 수 있다.

## 5. 네 번째 그룹: 상태 정보

세 개 속성이 Task의 현재 상태를 보여준다.

**status**는 Task의 진행 상태다. "pending"은 아직 시작 전, "in_progress"는 진행 중, "completed"는 완료를 의미한다.

**progress**는 진행률이다. 0부터 100까지의 숫자로 표현한다. 복잡한 Task의 경우 30%, 50%, 80% 같은 중간 진행률을 표시할 수 있다.

**stage_gate_status**는 특별한 속성이다. 22개 속성 중 유일하게 사람이 입력한다. Stage가 끝나면 PO(Product Owner)가 모든 결과물을 검토하고 최종 승인한다. "approved"면 다음 Stage로 넘어갈 수 있고, "rejected"면 수정이 필요하다.

## 6. 속성을 언제 채우는가

22개 속성을 한꺼번에 다 채우지 않는다. 작성 시점이 다르다.

**설계 단계에서 채우는 속성**: task_id, task_name, stage, area, level, dependencies, task_instruction, task_agent, verification_instruction, verification_agent. 프로젝트를 계획할 때 미리 정의한다. 총 10개다.

**작업 중에 채우는 속성**: status, progress, blockers. AI가 작업하면서 갱신한다.

**작업 완료 후 채우는 속성**: generated_files, duration, build_result. Task를 마치면 AI가 기록한다.

**검증 후 채우는 속성**: test_result, build_verification, integration_verification, comprehensive_verification, ai_verification_note. 검증 Agent가 검증을 마치면 기록한다.

**PO 승인 시 채우는 속성**: stage_gate_status. 사람이 최종 승인할 때 입력한다.

이렇게 단계별로 속성이 채워지면서 Task의 전체 이력이 완성된다.

## 7. 속성들의 연결 관계

22개 속성은 독립적이지 않다. 서로 연결되어 있다.

먼저 **실행 흐름**이 있다. task_instruction에 적힌 대로 task_agent가 작업을 수행한다. 작업이 끝나면 generated_files, duration, build_result가 기록된다.

다음으로 **검증 흐름**이 있다. verification_instruction에 적힌 대로 verification_agent가 검증한다. 검증이 끝나면 test_result, build_verification, integration_verification이 기록되고, 이를 종합해서 comprehensive_verification이 결정된다.

그리고 **상태 흐름**이 있다. status는 pending에서 시작해서 in_progress를 거쳐 completed가 된다. Stage의 모든 Task가 completed되면 stage_gate_status를 위한 PO 검토가 시작된다.

마지막으로 **의존성 관계**가 있다. dependencies에 나열된 Task들이 모두 completed 상태여야 현재 Task를 시작할 수 있다. 이것이 작업 순서를 자동으로 결정해준다.

## 8. 다음 단계

2편에서는 22개 속성의 역할과 연결 관계를 살펴봤다. Task가 무엇인지(식별), 어떻게 하는지(실행), 제대로 됐는지(검증), 지금 어떤지(상태)를 각각 다른 속성 그룹이 담당한다.

다음 편에서는 이 속성들이 배치되는 5×11 Matrix 구조를 살펴본다. Stage와 Area가 만나서 어떻게 Task들의 배치도가 되는지 알아보자.

---

*다음 편: 3편 | 5×11 Matrix (Stage × Area)*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 4,200자 / 작성자: Claude / 프롬프터: 써니**
