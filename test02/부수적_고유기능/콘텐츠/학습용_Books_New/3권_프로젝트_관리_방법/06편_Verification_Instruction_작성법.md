# 6편 | Verification Instruction 작성법

---

로그인 API를 만들었다. 테스트 한 번 해봤더니 잘 된다. 끝? 아니다.

"테스트 한 번 해봤더니 잘 된다"는 검증이 아니다. 정상적인 경우만 확인한 것이다. 비밀번호가 틀렸을 때는? 이미 로그인된 상태에서 다시 로그인하면? 이메일 형식이 잘못됐으면? 이런 경우에도 제대로 동작하는가?

SAL Grid에서는 모든 Task에 Verification Instruction(검증 지시사항)을 작성한다. Task Instruction이 "무엇을 만들어라"라면, Verification Instruction은 "이것들을 확인해라"다. 만드는 것과 검증하는 것은 별개의 작업이다.

## 1. 자기 검증은 왜 안 되는가

학교에서 시험을 치면 학생이 채점하지 않는다. 선생님이 채점한다. 왜? 학생은 자기 답이 맞다고 생각하기 때문이다. 객관적인 평가가 어렵다.

코드도 마찬가지다. 자기가 작성한 코드를 자기가 검증하면 문제를 놓치기 쉽다. "이렇게 했으니까 당연히 되겠지"라고 생각한다. 하지만 실제로는 안 될 수 있다.

SAL Grid에서는 Task Agent와 Verification Agent가 반드시 다르다. 코드를 작성한 Agent와 검증하는 Agent가 분리된다. backend-developer가 만든 코드는 code-reviewer가 검증한다. 새로운 눈으로 보면 작성자가 놓친 것을 발견할 수 있다.

## 2. 검증 기준은 객관적이어야 한다

"코드가 깔끔해야 한다"는 검증 기준이 아니다. 깔끔하다는 게 뭔가? 내가 보기엔 깔끔한데 다른 사람이 보기엔 지저분할 수 있다.

좋은 검증 기준은 누가 봐도 Pass/Fail을 똑같이 판단할 수 있어야 한다.

"ESLint 에러가 0개여야 한다"는 좋은 기준이다. 에러가 0개면 Pass, 1개라도 있으면 Fail. 명확하다.

"API 응답 시간이 500ms 이내여야 한다"도 좋은 기준이다. 측정할 수 있고, 숫자로 비교할 수 있다.

"UI가 예뻐야 한다"는 나쁜 기준이다. 대신 "디자인 시안과 일치해야 한다"라고 하면 기준이 생긴다. 시안과 비교해서 같으면 Pass, 다르면 Fail.

## 3. 세 가지 종류의 검증

Verification Instruction에는 세 가지 종류의 검증이 들어간다.

**첫째, 기능 검증**이다. Task Instruction에서 요구한 기능이 제대로 동작하는지 확인한다. 정상적인 경우(성공 케이스), 경계 상황(엣지 케이스), 잘못된 입력(에러 케이스)을 모두 테스트한다.

로그인 API라면: 올바른 이메일과 비밀번호로 로그인하면 토큰이 반환되는가? 이미 로그인된 사용자가 다시 로그인하면 어떻게 되는가? 비밀번호가 틀리면 401이 반환되는가?

**둘째, 빌드 검증**이다. 코드가 에러 없이 빌드되는지, 배포가 성공하는지, 실행 시 문제가 없는지 확인한다. 컴파일 에러, 린트 에러, 런타임 에러가 없어야 한다.

**셋째, 통합 검증**이다. 이 Task가 다른 Task들과 잘 연결되는지 확인한다. 선행 Task의 결과물을 제대로 사용하는지, 다른 Task와 충돌하지 않는지, 데이터가 정상적으로 흐르는지.

구독 취소 API가 subscriptions 테이블을 제대로 업데이트하는지, 취소 후 이메일 발송 함수를 정상적으로 호출하는지 확인하는 것이 통합 검증이다.

## 4. Task Instruction과 1:1로 대응

Verification Instruction은 Task Instruction의 거울이다. Task Instruction에서 "이렇게 해라"라고 한 모든 것에 대해 Verification Instruction에서 "이렇게 됐는지 확인해라"가 있어야 한다.

Task Instruction에 "성공 시 200을 반환하라"고 적었으면, Verification Instruction에 "성공 시 200이 반환되는지 확인"이 있어야 한다.

Task Instruction에 "cancelled_at 필드에 현재 시각을 기록하라"고 적었으면, Verification Instruction에 "cancelled_at 필드에 시각이 기록되었는지 확인"이 있어야 한다.

하나라도 빠지면 검증되지 않은 부분이 생긴다. 그 부분에서 문제가 생길 수 있다.

## 5. 검증 결과를 기록하는 방법

검증이 끝나면 결과를 22개 속성에 기록한다. 여러 속성에 나눠서 기록하는 이유는 나중에 어디서 문제가 생겼는지 빠르게 파악하기 위해서다.

test_result에는 테스트 결과를 기록한다. 단위 테스트 몇 개 중 몇 개 통과, 통합 테스트 몇 개 중 몇 개 통과, 수동 테스트 완료 여부.

build_verification에는 빌드 결과를 기록한다. 컴파일 성공 여부, 린트 에러 개수, 배포 성공 여부, 런타임 에러 여부.

integration_verification에는 통합 결과를 기록한다. 선행 Task 연동 확인, 다른 Task와 충돌 없음 확인, 데이터 흐름 정상 확인.

blockers에는 진행을 막는 문제가 있으면 기록한다. 선행 Task 미완료, 환경 설정 문제, 외부 API 문제 등.

comprehensive_verification에는 모든 것을 종합해서 최종 결론을 낸다. 모든 검증을 통과했으면 "Passed", 하나라도 실패했으면 "Failed".

## 6. 정상 케이스만 확인하면 안 되는 이유

사용자는 개발자가 예상한 대로 행동하지 않는다. 이메일 칸에 전화번호를 넣기도 하고, 버튼을 연속으로 누르기도 하고, 뒤로 가기 버튼을 누르다가 이상한 상태가 되기도 한다.

그래서 검증할 때 엣지 케이스와 에러 케이스를 반드시 포함해야 한다.

로그인 API라면:
- 정상: 올바른 정보로 로그인 → 성공
- 엣지: 비밀번호에 특수문자만 → 어떻게 되나?
- 에러: 빈 이메일 → 400 Bad Request여야 함
- 에러: 존재하지 않는 이메일 → 401이어야 함
- 에러: 비밀번호 틀림 → 401이어야 함

이 모든 경우를 Verification Instruction에 적어두고 검증한다.

## 7. 수동 검증과 자동 검증

모든 검증을 자동화할 수는 없다. API 응답 코드 확인은 테스트 코드로 자동화할 수 있지만, UI가 디자인 시안과 일치하는지는 눈으로 봐야 한다.

Verification Instruction을 작성할 때 어떤 것은 자동화 가능하고 어떤 것은 수동 확인이 필요한지 표시해두면 좋다. 자동화 가능한 것은 테스트 코드로 만들고, 수동 확인이 필요한 것은 체크리스트로 남긴다.

점점 자동화 범위를 넓혀가면 검증 시간이 줄어든다. 하지만 100% 자동화는 불가능하다. 사람의 눈으로 봐야 하는 것들이 있다.

## 8. 검증 없이 완료 보고하면 안 되는 이유

"완료했습니다"라고 보고했는데 나중에 문제가 발견되면 어떻게 되나? 다시 돌아가서 수정해야 한다. 그 사이에 다른 Task들이 이 결과물을 사용했을 수 있다. 도미노처럼 문제가 퍼진다.

검증을 하면 문제를 바로 발견한다. 완료 보고 전에 수정할 수 있다. 다른 Task에 영향을 주기 전에 해결한다.

검증을 건너뛰면 단기적으로는 시간이 절약되는 것 같다. 하지만 장기적으로는 더 많은 시간을 잡아먹는다. "급할수록 돌아가라"는 말이 여기에 딱 맞는다.

## 9. 다음 단계

6편에서는 Verification Instruction 작성법을 살펴봤다. 작성자와 검증자를 분리하고, 객관적인 기준으로 검증하고, 기능/빌드/통합을 모두 확인한다.

다음 편에서는 검증 시스템 전체와 Stage Gate를 다룬다. 개별 Task 검증을 넘어서 Stage 전체가 완료됐는지 확인하는 프로세스다.

---

*다음 편: 7편 | 검증 시스템과 Stage Gate*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,500자 / 작성자: Claude / 프롬프터: 써니**
