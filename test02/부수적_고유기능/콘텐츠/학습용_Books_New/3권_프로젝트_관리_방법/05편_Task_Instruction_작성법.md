# 5편 | Task Instruction 작성법

---

"로그인 기능 만들어줘"라고 AI에게 말하면 무슨 일이 벌어질까? AI는 열심히 뭔가를 만들어 낸다. 하지만 당신이 원했던 것과 다를 가능성이 높다. 소셜 로그인을 원했는데 이메일 로그인을 만들었을 수 있다. 성공 시 메인 페이지로 가길 원했는데 로그인 페이지에 그대로 있을 수 있다.

왜 이런 일이 벌어질까? 지시가 모호했기 때문이다. "로그인 기능"이 정확히 무엇인지 AI가 알 수 없었다. AI는 추측할 수밖에 없고, 추측은 틀릴 수 있다.

SAL Grid에서는 이 문제를 Task Instruction(작업 지시사항)으로 해결한다. 22개 속성 중 task_instruction 필드에 정확한 지시사항을 적는다. 지시가 명확할수록 AI의 결과물이 원하는 것에 가까워진다.

## 1. 좋은 Instruction의 다섯 가지 요소

좋은 Instruction에는 다섯 가지 요소가 있다.

**첫째, 목표**다. 이 Task가 끝나면 무엇이 달성되는가? "사용자가 Google 계정으로 로그인할 수 있다"처럼 최종 상태를 적는다.

**둘째, 입력과 출력**이다. 무엇을 받아서 무엇을 반환하는가? API라면 "user_id를 받아서 구독 상태 JSON을 반환한다"처럼 명시한다. UI라면 "로그인 버튼 클릭을 받아서 대시보드 페이지로 이동한다"처럼 적는다.

**셋째, 세부 요구사항**이다. 정확히 어떻게 구현해야 하는가? 사용할 라이브러리, 호출할 함수, 저장할 필드 등을 나열한다. "Supabase의 signInWithOAuth 함수를 사용하라. 로그인 성공 시 /dashboard로 리다이렉트하라."

**넷째, 예외 처리**다. 예상되는 오류 상황과 대처 방법을 적는다. "인증 실패 시 401 반환. 이미 취소된 구독이면 409 반환." 에러를 무시하라는 것이 아니라 어떻게 처리하라는 것인지 명확히 한다.

**다섯째, 참고 사항**이다. 다른 Task의 결과물을 사용해야 하거나, 특별히 주의할 점이 있으면 적는다. "이메일 발송은 S2BA2에서 구현한 sendEmail 함수를 사용하라. 환불 처리는 S4에서 별도로 구현한다."

## 2. 모호한 표현과 명확한 표현

같은 내용도 표현에 따라 결과가 달라진다.

"사용자 정보를 저장하라"는 모호하다. 어떤 정보를? 어디에? AI가 스스로 결정해야 한다. 반면 "users 테이블에 id, email, full_name, avatar_url, created_at 필드를 저장하라"는 명확하다. AI가 추측할 필요가 없다.

"에러 처리를 해라"는 모호하다. 어떤 에러를? 어떻게 처리해? 반면 "인증 실패 시 401, 데이터 없음 시 404, 중복 요청 시 409를 반환하라"는 명확하다.

"빠르게 동작해야 한다"는 모호하다. 빠르다는 게 1초인가? 10초인가? 반면 "API 응답 시간 500ms 이내"는 명확하다. 측정할 수 있다.

"예쁘게 만들어라"는 최악이다. 예쁘다는 기준이 없다. 반면 "디자인 시안 figma.com/xxx를 참조하라"는 명확하다. 기준이 있다.

## 3. 예시를 보여주는 것의 힘

복잡한 요구사항은 설명보다 예시가 효과적이다.

"API가 성공 시 적절한 JSON을 반환하라"고 하면 AI가 어떤 형식을 만들지 모른다. 하지만 예시를 보여주면 정확히 그 형식으로 만든다.

```
성공 시:
{
  "success": true,
  "data": {
    "subscription_id": "sub_123",
    "status": "cancelled"
  }
}

실패 시:
{
  "success": false,
  "error": {
    "code": "ALREADY_CANCELLED",
    "message": "이미 취소된 구독입니다"
  }
}
```

이렇게 예시를 주면 AI는 이 형식을 그대로 따른다. success(성공 여부), data(데이터), error(오류 정보), code(오류 코드), message(오류 메시지) 같은 필드명도 예시 그대로 사용한다.

## 4. 의존성을 명시해야 하는 이유

Task는 혼자 존재하지 않는다. 다른 Task의 결과물을 가져다 쓰는 경우가 많다.

로그인 UI를 만들 때 Supabase Client가 필요하다. 이 Client는 S1BI1에서 만들었다. 구독 취소 후 이메일을 보내려면 sendEmail 함수가 필요하다. 이 함수는 S2BA2에서 만들었다.

Instruction에 이 관계를 적어두면 AI가 찾아서 사용한다. "S1BI1에서 생성한 supabaseClient를 import해서 사용하라." 이렇게 적으면 AI가 해당 파일을 찾아서 올바르게 연결한다.

적어두지 않으면 AI가 새로 만들 수 있다. 이미 있는 Client를 두고 또 만드는 것이다. 중복 코드가 생기고, 나중에 수정할 때 문제가 된다.

## 5. 완료 기준을 구체적으로

"기능이 잘 동작해야 한다"는 완료 기준이 아니다. 누가 판단하나? 기준이 뭔가?

좋은 완료 기준은 체크리스트 형태다.

```
완료 기준:
1. POST /api/subscription/cancel 호출 시 200 반환
2. 구독 상태가 'cancelled'로 변경됨
3. cancelled_at 필드에 현재 시각 기록됨
4. 중복 취소 시 409 에러 반환
5. 취소 후 확인 이메일 발송됨
```

이 다섯 가지를 확인하면 Task가 완료됐는지 객관적으로 알 수 있다. 검증할 때도 이 체크리스트를 사용한다.

## 6. Area별 Instruction의 차이

Frontend, Backend, Database - 영역에 따라 Instruction에서 강조하는 부분이 다르다.

**Frontend Instruction**은 UI 요소와 사용자 인터랙션을 상세히 적는다. 어떤 버튼이 있고, 클릭하면 무엇이 일어나고, 에러가 나면 어떻게 표시하는지. 디자인 시안이 있으면 참조 링크를 적는다.

**Backend Instruction**은 엔드포인트, 입력, 출력, 처리 로직, 에러 처리를 상세히 적는다. API 명세에 가깝다. 어떤 HTTP 메서드를 쓰고, 어떤 상태 코드를 반환하는지.

**Database Instruction**은 테이블 구조, 필드 정의, 관계, 제약조건을 상세히 적는다. RLS(Row Level Security, 행 단위 접근 제어) 정책도 여기서 정의한다. SQL 예시를 직접 포함하는 경우가 많다.

## 7. 점점 더 좋은 Instruction을 쓰게 된다

처음에는 Instruction 쓰는 데 시간이 오래 걸린다. 뭘 적어야 할지 모르겠고, 너무 상세한 것 같기도 하다.

하지만 몇 번 해보면 감이 온다. 어떤 정보가 있어야 AI가 정확하게 작업하는지 알게 된다. 모호하게 적었다가 결과물을 수정하는 시간보다 Instruction을 상세히 쓰는 시간이 짧다는 것도 알게 된다.

프로젝트를 진행하면서 Instruction 템플릿도 쌓인다. 비슷한 유형의 Task는 이전 Instruction을 참고해서 빠르게 쓸 수 있다. "지난번 API Instruction에서 입출력 형식만 바꾸면 되겠다."

## 8. 다음 단계

5편에서는 Task Instruction 작성법을 살펴봤다. 좋은 Instruction은 목표, 입력/출력, 세부 요구사항, 예외 처리, 참고 사항을 포함한다. 모호한 표현 대신 구체적이고 측정 가능한 표현을 사용한다.

다음 편에서는 Verification Instruction을 다룬다. Task가 완료된 후 어떻게 검증할지 정의하는 방법이다. Task Instruction이 "무엇을 해라"라면, Verification Instruction은 "어떻게 확인해라"다.

---

*다음 편: 6편 | Verification Instruction 작성법*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,600자 / 작성자: Claude / 프롬프터: 써니**
