# 4편 | Task 생성과 의존성 관리

프로젝트를 Task로 분할하는 것은 요리를 레시피로 만드는 것과 비슷하다. "저녁 만들기"라고 하면 너무 막연하다. "양파 썰기", "고기 볶기", "소스 끓이기"처럼 단계별로 나눠야 따라할 수 있다.

Task도 마찬가지다. "인증 시스템 구현"은 너무 크다. 어디서 시작해야 할지, 언제 끝난 건지 알 수 없다. 하지만 "로그인 API 구현", "회원가입 UI 만들기", "세션 관리 설정"처럼 나누면 하나씩 해결할 수 있다.

## 1. 좋은 Task의 조건

Task를 나눌 때 네 가지 조건을 확인한다.

첫째, **단일 책임**이다. 하나의 Task는 하나의 일만 한다. "로그인 API 구현"은 좋지만, "로그인 API 구현하고 회원가입도 처리"는 두 가지 일이다. 나눠야 한다.

둘째, **독립 테스트**다. 이 Task만으로 테스트할 수 있어야 한다. 로그인 API를 만들었으면 Postman으로 API를 호출해서 잘 되는지 확인할 수 있어야 한다. "다른 것도 완성되어야 테스트 가능"하다면 Task가 잘못 나뉜 것이다.

셋째, **명확한 완료 기준**이다. "기능이 잘 동작함"은 완료 기준이 아니다. "POST /api/auth/login 호출 시 200 응답과 JWT 토큰 반환"처럼 객관적으로 확인할 수 있어야 한다.

넷째, **명확한 결과물**이다. Task가 끝나면 뭔가 생겨야 한다. 파일이든, 설정이든, 문서든. "로그인 API 구현"의 결과물은 `login.js` 파일이다.

## 2. 너무 크거나 너무 작으면

"인증 시스템 전체 구현"은 너무 크다. 범위가 모호하고, 완료 기준이 불명확하고, 진행률을 파악하기 어렵다. 이런 Task는 반드시 분할해야 한다.

반면 "버튼 색상 빨간색으로 변경"은 너무 작다. 이런 수준으로 Task를 만들면 Task 수가 수백 개가 된다. 관리하는 데 드는 시간이 실제 작업 시간보다 길어진다.

적절한 크기는 "한 번의 집중으로 완료할 수 있는 작업 단위"다. 보통 몇 시간에서 하루 정도의 작업량이 적당하다.

## 3. 의존성이란

Task들은 혼자 존재하지 않는다. 어떤 Task는 다른 Task가 먼저 끝나야 시작할 수 있다. 이 관계를 의존성이라고 한다.

집을 짓는 것을 생각해보자. 벽을 세우려면 기초가 있어야 한다. 지붕을 올리려면 벽이 있어야 한다. 기초 → 벽 → 지붕. 이것이 의존성이다.

SAL Grid에서는 dependencies 속성으로 이 관계를 표현한다. "구독 관리 API"가 "users 테이블"과 "인증 설정"이 필요하다면, dependencies에 `["S1D1", "S1S1"]`이라고 적는다. S1D1과 S1S1이 완료되어야 이 Task를 시작할 수 있다는 뜻이다.

## 4. 의존성의 세 가지 유형

의존성은 보통 세 가지 이유로 생긴다.

**데이터 의존성**은 데이터가 있어야 기능을 만들 수 있을 때 생긴다. 사용자 API를 만들려면 users 테이블이 먼저 있어야 한다. 테이블 없이 API를 만들 수는 없다.

**기능 의존성**은 다른 기능이 있어야 연결할 수 있을 때 생긴다. 로그인 UI가 로그인 API를 호출해야 한다면, API가 먼저 있어야 UI에서 호출할 수 있다. 물론 API 명세만 정의하고 병렬로 작업하는 방법도 있지만, 가장 단순한 방식은 API 먼저, UI 나중이다.

**설정 의존성**은 설정이 되어 있어야 기능을 구현할 수 있을 때 생긴다. 세션 관리를 구현하려면 인증 시스템이 먼저 설정되어 있어야 한다. 인증이 없으면 세션이 의미가 없다.

## 5. 의존성을 최소화해야 하는 이유

의존성이 많으면 병렬 작업이 불가능해진다. A가 B, C, D, E에 의존한다면, A를 시작하려면 B, C, D, E가 모두 끝나야 한다. 그 중 하나라도 늦어지면 A도 늦어진다.

그래서 의존성은 꼭 필요한 것만 명시해야 한다. "혹시 몰라서" 넣는 의존성은 프로젝트를 느리게 만든다.

또한 직접 의존성만 명시한다. A → B → C일 때, C는 B에만 의존한다고 적는다. A는 적지 않는다. B가 이미 A에 의존하기 때문에, C가 B에 의존하면 자동으로 A도 의존하는 것이 된다.

## 6. 순환 의존성은 왜 안 되는가

가끔 의존성이 원을 그릴 때가 있다. A가 B에 의존하고, B가 C에 의존하고, C가 다시 A에 의존한다. A → B → C → A. 이것이 순환 의존성이다.

순환 의존성이 있으면 어떤 Task도 시작할 수 없다. A를 하려면 C가 끝나야 하고, C를 하려면 B가 끝나야 하고, B를 하려면 A가 끝나야 한다. 영원히 시작하지 못하는 교착 상태(어느 것도 시작할 수 없는 막힌 상태)가 된다.

실제로는 "UI가 API 필요" + "API가 UI 필요" 같은 상황에서 이런 문제가 생긴다. 해결책은 둘 중 하나를 먼저 할 수 있게 설계를 바꾸는 것이다.

예를 들어 API 명세를 먼저 정의한다. UI와 API가 둘 다 명세에만 의존하게 하면 서로 의존하지 않는다. API는 명세대로 구현하고, UI는 명세대로 호출한다. 둘이 동시에 작업해도 된다.

## 7. 의존성 다이어그램

복잡한 프로젝트에서는 의존성을 글로 적는 것보다 그림으로 그리는 것이 이해하기 쉽다.

S1의 기초 작업들이 있고, 그것들이 S2의 여러 Task로 화살표가 뻗어나간다. S2의 Task들이 다시 S3로 연결된다. 이 그림을 보면 어떤 Task가 먼저 끝나야 하는지, 어떤 Task들이 동시에 진행 가능한지 한눈에 파악된다.

화살표가 원을 그리지 않는지도 그림으로 쉽게 확인할 수 있다. 순환 의존성이 있으면 화살표를 따라가다 보면 다시 출발점으로 돌아온다.

## 8. 병렬 작업의 기회

의존성을 잘 관리하면 병렬 작업의 기회가 보인다.

같은 Stage에서 서로 의존하지 않는 Task들은 동시에 진행할 수 있다. Frontend 팀이 UI를 만드는 동안 Backend 팀이 API를 만들 수 있다. 두 팀이 서로를 기다릴 필요가 없다.

하지만 의존성을 잘못 설정하면 이 기회가 사라진다. 불필요한 의존성 하나가 병렬 작업을 순차 작업으로 바꿔버린다.

## 9. 핵심 Task를 먼저

의존성 다이어그램에서 화살표가 많이 나가는 Task가 있다. 많은 Task가 이 Task에 의존한다는 뜻이다. 이런 Task는 병목이 될 수 있다.

데이터베이스 스키마가 대표적이다. API도, 보안도, 테스트도 스키마에 의존한다. 스키마가 늦어지면 프로젝트 전체가 늦어진다.

그래서 이런 핵심 Task는 우선순위를 높여서 빨리 완료해야 한다. 스키마가 끝나면 여러 팀이 동시에 작업을 시작할 수 있다.

## 10. Task ID 부여 규칙

Task ID는 Stage + Area + Level로 만든다. S2BA1은 S2 단계, BA 영역, 첫 번째 작업이다.

Level은 같은 Stage, 같은 Area 내에서 순서대로 매긴다. S2BA1 다음은 S2BA2, 그 다음은 S2BA3이다.

주의할 점은 Level이 의존성 순서를 의미하지 않는다는 것이다. S2BA2가 S2BA1에 의존할 수도 있고, 의존하지 않을 수도 있다. Level은 단순히 같은 칸 안에서 Task를 구분하기 위한 번호일 뿐이다.

중간에 Task를 추가해야 할 때는 새 번호를 부여한다. S2BA1과 S2BA2 사이에 넣고 싶다면 S2BA3으로 만든다. S2BA1.5 같은 소수점 번호는 사용하지 않는다.

## 11. 다음 단계

4편에서는 Task를 생성하고 의존성을 관리하는 방법을 살펴봤다. 좋은 Task는 단일 책임, 독립 테스트, 명확한 완료 기준, 명확한 결과물을 갖는다. 의존성은 꼭 필요한 것만 최소한으로 설정하고, 순환 의존성은 반드시 피해야 한다.

다음 편에서는 Task Instruction을 작성하는 방법을 살펴본다. AI가 정확하게 작업을 수행하려면 지시사항이 명확해야 한다.

---

*다음 편: 5편 | Task Instruction 작성법*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,800자 / 작성자: Claude / 프롬프터: 써니**
