# 1편 | SAL Grid 개요와 핵심 개념

---

SAL Grid는 AI와 협업하여 프로젝트를 관리하는 시스템이다. 처음 듣는 사람은 "또 하나의 프로젝트 관리 도구인가?"라고 생각할 수 있지만, SAL Grid는 기존 도구들과 근본적으로 다른 접근법을 취한다. 이 편에서는 SAL Grid가 무엇이고, 왜 만들어졌으며, 어떤 원리로 작동하는지 살펴본다.

## 1. SAL Grid의 탄생 배경

### 1-1 AI 협업의 새로운 문제

2024년을 기점으로 AI가 단순한 질문 응답을 넘어 실제 코드를 작성하고 파일을 생성하는 수준에 도달했다. Claude Code 같은 도구를 사용하면 "로그인 페이지 만들어줘"라고 말하면 실제로 HTML 파일이 생성된다. 이론상으로는 AI에게 프로젝트 전체를 맡길 수 있게 된 것이다.

하지만 실제로 해보면 문제가 발생한다. AI에게 "쇼핑몰 만들어줘"라고 하면 어떻게 될까? AI는 열심히 코드를 작성하지만, 결과물은 엉망이 되기 쉽다. 파일이 여기저기 흩어지고, 앞서 만든 것과 뒤에 만든 것이 연결되지 않으며, 세션이 끊어지면 어디까지 했는지 파악하기 어렵다.

이런 문제가 발생하는 이유는 AI가 "전체 그림"을 보지 못하기 때문이다. AI는 주어진 요청에 최선을 다해 응답하지만, 프로젝트 전체의 구조와 흐름을 체계적으로 관리하지는 못한다. 마치 뛰어난 목수에게 집을 지어달라고 하면서 설계도 없이 "일단 시작해"라고 하는 것과 같다.

### 1-2 기존 도구들의 한계

Jira, Trello, Notion 같은 프로젝트 관리 도구들이 있지 않은가? 이런 도구들은 사람이 작업을 관리할 때는 잘 작동한다. 하지만 AI와 협업할 때는 한계가 있다.

첫째, AI가 이런 도구들을 직접 읽고 업데이트하기 어렵다. Jira의 티켓을 읽으려면 API 연동이 필요하고, 작업이 끝나면 다시 API로 상태를 업데이트해야 한다. 복잡하고 번거롭다.

둘째, 기존 도구들은 AI의 특성을 고려하지 않았다. AI는 세션이 끊어지면 이전 컨텍스트(대화 맥락)를 잃는다. 긴 대화를 하다 보면 토큰 한계(AI가 한 번에 처리할 수 있는 텍스트 용량 제한)에 도달한다. 여러 작업을 동시에 진행하면 어디까지 했는지 헷갈린다. 기존 도구들은 이런 AI의 특성을 전혀 고려하지 않았다.

셋째, 작업 간의 의존성을 체계적으로 관리하지 못한다. "로그인 기능"을 만들려면 먼저 "데이터베이스 스키마"가 있어야 하고, "인증 시스템"이 설정되어야 한다. 이런 의존성을 무시하고 작업하면 나중에 전부 다시 해야 한다.

### 1-3 새로운 시스템의 필요성

이런 문제들을 해결하기 위해 SAL Grid가 만들어졌다. SAL Grid의 핵심 아이디어는 간단하다. AI가 읽고 쓸 수 있는 형식으로 프로젝트의 모든 정보를 체계적으로 정리하자는 것이다.

AI에게 "이 Grid를 보고 다음 작업을 해"라고 하면, AI는 Grid에서 현재 상태를 파악하고, 의존성을 확인하고, 작업을 수행한 뒤, 결과를 다시 Grid에 기록한다. 세션이 끊어져도 Grid가 남아있으므로 다음 세션에서 이어서 작업할 수 있다.

## 2. SAL이라는 이름의 의미

### 2-1 3차원 좌표계

SAL은 Stage, Area, Level의 약자이다. 이 세 가지 축으로 프로젝트의 모든 작업을 정의한다.

Stage는 프로젝트의 진행 단계를 나타낸다. S1은 개발 준비, S2는 개발 1차, S3는 개발 2차, S4는 개발 3차, S5는 운영 단계이다. 집을 짓는다면 S1에서 설계도를 그리고, S2에서 기초 공사를 하고, S3에서 골조를 올리고, S4에서 마감을 하고, S5에서 입주하는 것과 같다.

Area는 작업의 기술 영역을 나타낸다. 프론트엔드, 백엔드, 데이터베이스, 보안 등 11개의 영역으로 나뉜다. 집을 짓는다면 전기, 배관, 인테리어, 외장 등 전문 분야가 나뉘는 것과 같다.

Level은 같은 Stage와 Area 내에서의 작업 순서를 나타낸다. 1번 작업, 2번 작업, 3번 작업 순서로 진행된다.

### 2-2 Task ID의 구조

이 세 가지 축을 조합하면 Task ID가 만들어진다. 예를 들어 S2BA1이라는 ID가 있다면, S2는 개발 1차 단계, BA는 Backend API 영역, 1은 첫 번째 작업이라는 뜻이다.

이 ID만 보면 "개발 1차 단계에서 수행하는 백엔드 API 영역의 첫 번째 작업"이라는 것을 즉시 알 수 있다. AI도 이 ID를 보고 해당 작업의 위치와 맥락을 파악한다.

마치 건물의 주소가 "서울시 강남구 테헤란로 123"처럼 위치를 특정하듯, Task ID는 프로젝트 내에서 작업의 위치를 특정한다. "S2BA1 작업해줘"라고 하면 AI는 정확히 어떤 작업인지 찾아갈 수 있다.

### 2-3 Grid라는 형태

SAL로 정의된 작업들을 격자(Grid) 형태로 배열하면 전체 프로젝트의 구조가 한눈에 보인다. 가로축에는 11개의 Area가 배열되고, 세로축에는 5개의 Stage가 배열된다. 각 칸에는 해당 Stage와 Area에 속하는 Task들이 들어간다.

이 Grid를 보면 프로젝트의 현재 상태를 파악할 수 있다. 어떤 Stage까지 완료되었는지, 어떤 Area에 작업이 집중되어 있는지, 어떤 작업이 막혀있는지 한눈에 알 수 있다.

## 3. 22개 속성

### 3-1 왜 22개인가

SAL Grid에서 각 Task는 22개의 속성을 가진다. 처음에는 "22개나 필요한가?"라고 생각할 수 있지만, 각 속성은 나름의 역할이 있다.

AI와 협업할 때 가장 중요한 것은 "명확성"이다. 사람끼리는 "대충 이런 느낌으로"라고 해도 통하지만, AI에게는 명확한 지시가 필요하다. 22개 속성은 "무엇을 해야 하는지", "어떻게 검증할 것인지", "현재 상태가 어떤지"를 빈틈없이 정의한다.

### 3-2 속성의 분류

22개 속성은 크게 네 가지 그룹으로 나뉜다.

첫째, 기본 정보 영역이다. Task ID, 이름, Stage, Area, Level 같은 기본적인 식별 정보가 여기에 속한다. "이 작업이 무엇인가"를 정의한다.

둘째, 작업 정의 영역이다. Task Instruction(작업 지시), Task Agent(수행자), 의존성, 실행 유형 같은 정보가 여기에 속한다. "어떻게 작업할 것인가"를 정의한다.

셋째, 작업 실행 영역이다. 진행률, 상태, 생성된 파일, 수정 이력 같은 정보가 여기에 속한다. AI가 작업을 수행하면서 채워나가는 영역이다.

넷째, 검증 영역이다. Verification Instruction(검증 지시), 테스트 결과, 빌드 검증, 통합 검증, 최종 검증 상태 같은 정보가 여기에 속한다. "작업이 제대로 되었는가"를 확인한다.

### 3-3 작성자와 검증자 분리

22개 속성 중 주목할 점은 Task Agent와 Verification Agent가 분리되어 있다는 것이다. 작업을 수행하는 AI와 검증하는 AI가 다르다.

왜 이렇게 했을까? 자기가 만든 것을 자기가 검증하면 객관성이 떨어지기 때문이다. 코드를 작성한 개발자가 "내 코드는 완벽해"라고 생각하는 것처럼, AI도 자신이 생성한 결과물에 대해 편향을 가질 수 있다.

그래서 SAL Grid에서는 작업을 수행하는 Agent와 검증하는 Agent를 분리한다. 백엔드 개발 작업은 backend-developer Agent가 수행하고, 그 결과는 code-reviewer Agent가 검증한다. 이렇게 하면 품질이 높아진다.

## 4. 의존성 관리

### 4-1 의존성이란

프로젝트에서 작업들은 서로 연결되어 있다. 로그인 기능을 만들려면 먼저 사용자 테이블이 있어야 한다. 결제 기능을 만들려면 먼저 상품 정보가 있어야 한다. 이런 "먼저 이것이 있어야 저것을 할 수 있다"는 관계를 의존성이라고 한다.

SAL Grid에서는 각 Task에 dependencies 필드가 있다. 여기에 선행 Task의 ID를 기록한다. S2BA1의 dependencies가 ["S1D1", "S1S1"]이라면, S2BA1을 수행하기 전에 S1D1과 S1S1이 먼저 완료되어야 한다는 뜻이다.

### 4-2 자동 순서 결정

의존성 정보가 있으면 AI는 자동으로 작업 순서를 결정할 수 있다. "S2 작업해줘"라고 하면 AI는 S2에 속한 모든 Task의 의존성을 분석하여 올바른 순서로 작업을 진행한다.

의존성이 없는 작업들은 병렬로 진행할 수도 있다. 프론트엔드 작업과 백엔드 작업이 서로 의존하지 않는다면 동시에 진행해도 된다. 이렇게 하면 전체 프로젝트 완료 시간이 단축된다.

### 4-3 의존성 체인

의존성은 연쇄적으로 이어질 수 있다. S3의 작업이 S2의 작업에 의존하고, S2의 작업이 S1의 작업에 의존한다면, S3 작업을 하려면 S1과 S2가 모두 완료되어야 한다.

이런 의존성 체인을 시각화하면 프로젝트의 "크리티컬 패스"를 파악할 수 있다. 어떤 작업이 지연되면 전체 프로젝트가 지연되는지, 어떤 작업은 여유가 있는지 알 수 있다.

## 5. Stage Gate(관문)

### 5-1 Stage Gate란

Stage Gate는 각 Stage 사이에 있는 "관문"이다. S1에서 S2로 넘어가려면 S1 Gate를 통과해야 하고, S2에서 S3로 넘어가려면 S2 Gate를 통과해야 한다.

Gate를 통과하려면 해당 Stage의 모든 Task가 완료되고 검증을 통과해야 한다. 하나라도 미완료이거나 검증에 실패하면 다음 Stage로 넘어갈 수 없다.

### 5-2 왜 Gate가 필요한가

Gate가 없으면 어떻게 될까? 기초 공사가 제대로 안 된 상태에서 골조를 올리면 건물이 무너진다. 마찬가지로 S1의 인증 시스템이 불완전한 상태에서 S2의 로그인 기능을 만들면 나중에 전부 다시 해야 한다.

Stage Gate는 이런 문제를 방지한다. 각 단계가 확실히 완료된 후에만 다음 단계로 넘어가므로, 나중에 돌아와서 다시 작업하는 일이 줄어든다.

### 5-3 검증 프로세스

Stage Gate 통과를 위한 검증은 세 단계로 이루어진다.

첫 번째는 Task 검증이다. 각 Task가 완료될 때마다 Verification Agent가 해당 Task의 결과물을 검증한다.

두 번째는 Stage 전체 검증이다. Stage의 모든 Task가 완료되면 Main Agent가 전체를 종합적으로 검증한다. 개별 Task는 문제없지만 Task들 간의 연동에 문제가 있을 수 있기 때문이다.

세 번째는 PO(Project Owner) 승인이다. AI 검증을 통과한 후 사람이 최종 확인한다. 실제로 기능이 제대로 작동하는지, 요구사항에 맞는지 확인하고 승인한다.

## 6. SAL Grid가 해결하는 문제

### 6-1 세션 단절 문제

AI와 대화하다 보면 세션이 끊어지는 경우가 있다. 긴 작업 중에 연결이 끊어지거나, 대화가 너무 길어져서 AI의 기억 용량 한계에 도달하거나, 실수로 창을 닫는 경우이다.

기존에는 세션이 끊어지면 처음부터 다시 설명해야 했다. "어디까지 했더라, 뭘 만들고 있었더라" 하면서 컨텍스트를 복구하는 데 시간이 걸렸다.

SAL Grid를 사용하면 이 문제가 해결된다. Grid에 모든 상태가 기록되어 있으므로, 새 세션에서 "Grid 보고 이어서 작업해줘"라고 하면 된다. AI는 Grid를 읽고 현재 상태를 파악한 뒤 작업을 이어간다.

### 6-2 일관성 문제

여러 세션에 걸쳐 프로젝트를 진행하면 일관성이 깨지기 쉽다. 파일 이름 규칙이 달라지거나, 코드 스타일이 달라지거나, 폴더 구조가 뒤죽박죽 된다.

SAL Grid에서는 규칙들이 명문화되어 있다. 파일 명명 규칙, 저장 위치 규칙, 코드 스타일 규칙 등이 문서로 정리되어 있고, AI는 이 규칙을 참조하여 작업한다. 세션이 바뀌어도 규칙은 동일하므로 일관성이 유지된다.

### 6-3 추적 문제

프로젝트가 커지면 "뭘 했고 뭘 안 했는지" 파악하기 어려워진다. 특히 AI와 대화로만 작업하면 기록이 남지 않아서 나중에 추적하기 어렵다.

SAL Grid에서는 모든 작업이 기록된다. 어떤 Task가 완료되었는지, 어떤 파일이 생성되었는지, 검증 결과는 어떠한지 모두 Grid에 남는다. 문제가 생기면 이력을 추적하여 원인을 파악할 수 있다.

## 7. 다음 단계

1편에서는 SAL Grid의 개요와 핵심 개념을 살펴보았다. SAL Grid는 AI와의 협업을 위해 만들어진 프로젝트 관리 시스템이다. Stage, Area, Level의 3차원 좌표로 작업을 정의하고, 22개 속성으로 작업의 모든 측면을 기록하며, Stage Gate로 품질을 보장한다.

다음 편에서는 22개 속성 각각의 의미와 역할을 자세히 살펴본다. 각 속성이 왜 필요하고, 어떻게 채워지며, AI가 어떻게 활용하는지 알아본다.

---

*다음 편: 2편 | 22개 속성 정의*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 5,100자 / 작성자: Claude / 프롬프터: 써니**
