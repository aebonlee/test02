# 10편 | Order Sheet 제도

---

"로그인 페이지 만들어줘. 아, 그리고 Google 로그인도 되게 해줘. 비밀번호 찾기도 넣고. 아 맞다, 회원가입도 필요하지. 디자인은 깔끔하게."

이렇게 대화로 일을 시키면 어떻게 될까? AI는 열심히 만들기는 하는데, 원하던 것과 다를 가능성이 높다. "깔끔하게"가 무슨 뜻인지 모르고, 어떤 순서로 만들어야 하는지 불분명하고, 결과물을 어디에 저장해야 하는지도 모호하다.

더 큰 문제는 기록이 남지 않는다는 것이다. 세션이 끝나면 대화 내용이 사라진다. 나중에 "그때 뭘 요청했더라?"를 확인하려면 대화 기록을 뒤져야 한다. 팀원에게 공유하기도 어렵다.

SAL Grid에서는 이 문제를 Order Sheet로 해결한다. 대화 대신 구조화된 문서로 작업을 요청한다.

## 1. Order Sheet란

Order Sheet는 AI에게 작업을 요청하는 공식 문서다. 식당의 주문서를 생각하면 된다. 손님이 "맛있는 거 주세요"라고 하면 요리사가 곤란하다. 하지만 주문서에 "1번 메뉴 1개, 맵게, 밥 추가"라고 적혀 있으면 명확하다.

Order Sheet에는 필요한 정보가 구조화되어 들어간다. 어떤 Task를 요청하는지, 어떤 파일을 만들어야 하는지, 어떤 규칙을 따라야 하는지, 선행 작업이 무엇인지.

JSON 형식으로 작성되어 AI가 파싱하기 쉽다. 사람이 읽기도 쉽다. 파일로 저장되어 나중에 찾아볼 수 있다.

## 2. 왜 구조화된 문서인가

구조화의 첫 번째 장점은 명확성이다. "로그인 페이지 만들어줘"는 모호하다. 하지만 Order Sheet에는 Task ID, 결과물 경로, 필수 규칙 참조가 명시된다. AI가 추측할 여지가 줄어든다.

두 번째 장점은 추적 가능성이다. Order Sheet는 파일로 저장된다. 언제 무슨 작업을 요청했는지 기록이 남는다. 나중에 "그때 왜 이렇게 만들었지?"를 확인할 수 있다.

세 번째 장점은 일관성이다. 매번 같은 형식을 사용하니까 품질이 균일하다. 어떤 Task는 자세히 요청하고 어떤 Task는 대충 요청하는 일이 없다.

네 번째 장점은 세션 독립성이다. 세션이 끊어져도 Order Sheet 파일은 남아 있다. 새 세션에서 파일을 읽으면 이전 요청을 바로 파악할 수 있다.

## 3. Order Sheet의 구성

Order Sheet는 몇 가지 핵심 필드로 구성된다.

order_id는 Order의 고유 식별자다. ORDER-S2F1-251218처럼 어떤 Task를 언제 요청했는지 알 수 있게 만든다.

task_id는 SAL Grid의 Task ID다. S2F1, S3BA2 같은 형식. 이 Order가 어떤 Task에 관한 것인지 연결한다.

instructions는 작업 지시사항이다. 무엇을 어떻게 만들어야 하는지 설명한다.

expected_output은 예상 결과물이다. 어떤 파일이 어디에 생성되어야 하는지 경로까지 명시한다.

dependencies는 선행 Task다. 이 작업을 하려면 먼저 완료되어 있어야 하는 Task 목록이다.

rules_reference는 참조해야 하는 규칙 파일 목록이다. 파일 명명 규칙, 저장 위치 규칙 같은 것들. 이 필드가 있으면 AI가 규칙을 지키면서 작업한다.

## 4. Orders 폴더와 Reports 폴더

Order Sheet 시스템은 두 개의 폴더를 사용한다.

Orders 폴더에는 요청이 저장된다. 사람이 Order Sheet를 작성해서 Claude Code에 전달하면, Claude Code는 이것을 Orders 폴더에 저장한다. 그리고 작업을 시작한다.

Reports 폴더에는 결과가 저장된다. Claude Code가 작업을 완료하면 결과 보고서를 Reports 폴더에 저장한다. 어떤 파일을 생성했는지, 검증 결과가 어떤지, 다음 작업이 무엇인지.

이 구조의 장점은 요청과 결과가 분리된다는 것이다. Orders 폴더를 보면 무엇을 요청했는지 알 수 있고, Reports 폴더를 보면 무엇이 완료됐는지 알 수 있다.

## 5. 처리 흐름

Order Sheet가 처리되는 흐름은 이렇다.

사람이 대시보드에서 Order Sheet를 작성한다. 템플릿을 선택하고 필요한 정보를 입력한다. 작성이 끝나면 클립보드에 복사하거나 JSON 파일로 저장한다.

Claude Code에 Order Sheet를 전달한다. 클립보드에서 붙여넣거나 파일을 지정한다. Claude Code는 Order Sheet를 받으면 먼저 Orders 폴더에 저장한다. 이 단계를 빠뜨리면 안 된다. 기록이 남아야 하기 때문이다.

Claude Code가 작업을 수행한다. Order Sheet에 명시된 대로 코드를 작성하고 파일을 생성한다. rules_reference에 있는 규칙을 따른다.

작업이 끝나면 Reports 폴더에 결과를 저장한다. 완료 보고서에는 생성된 파일 목록, 검증 결과, 다음 단계 등이 포함된다.

사람은 대시보드에서 Reports를 불러와서 결과를 확인한다. 문제가 없으면 다음 작업으로 넘어간다.

## 6. Stage 단위 Order Sheet

개별 Task가 아니라 Stage 전체를 요청할 수도 있다. S3 Stage 전체를 작업해달라고 요청하면, Claude Code는 SAL Grid에서 S3에 해당하는 모든 Task를 찾아서 순서대로 처리한다.

이때 중요한 원칙이 있다. Grid가 진실의 원천이다. Order Sheet는 "S3를 작업해라"라고만 지시한다. 구체적으로 어떤 Task가 있는지, 어떤 순서로 해야 하는지, 의존성이 무엇인지는 모두 Grid에서 읽어온다.

Order Sheet가 Grid를 대체하는 것이 아니다. Order Sheet는 "Grid 보고 해라"라고 지시하는 트리거일 뿐이다. 실제 정보는 Grid에 있다.

## 7. 메모리 문제의 해결

AI와 대화하면 메모리 문제가 있다. 세션이 끝나면 대화 내용을 잊어버린다. 세션 중에도 대화가 길어지면 앞부분을 잊어버린다.

Order Sheet 시스템은 이 문제를 해결한다. 요청은 Orders 폴더에, 결과는 Reports 폴더에 파일로 저장된다. 세션이 끝나도 파일은 남아 있다.

새 세션이 시작되면 Orders와 Reports 폴더를 확인한다. 어떤 작업이 요청됐고 어떤 작업이 완료됐는지 바로 파악할 수 있다. "지난번에 뭘 했더라?"가 아니라 파일을 읽으면 된다.

work_log도 비슷한 역할을 하지만, Order Sheet는 더 구조화되어 있다. JSON 형식이라 필드별로 검색할 수 있고, 요청과 결과가 명확히 분리된다.

## 8. 다음 단계

10편에서는 Order Sheet 제도를 살펴봤다. 대화 대신 구조화된 문서로 작업을 요청하면 명확성, 추적 가능성, 일관성, 세션 독립성이 확보된다.

다음 편에서는 AI 작업 6대 규칙을 살펴본다. AI가 일관되게 작업하도록 만드는 규칙들이다.

---

*다음 편: 11편 | AI 작업 6대 규칙*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,200자 / 작성자: Claude / 프롬프터: 써니**
