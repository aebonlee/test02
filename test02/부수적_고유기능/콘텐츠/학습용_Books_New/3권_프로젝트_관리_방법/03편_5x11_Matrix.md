# 3편 | 5×11 Matrix (Stage × Area)

1편에서 SAL Grid의 3차원 좌표계를 알았고, 2편에서 22개 속성을 배웠다. 이제 실제로 Task들이 어떻게 배치되는지 살펴볼 차례다.

SAL Grid에서 모든 Task는 거대한 격자판 위에 놓인다. 이 격자판을 Matrix라고 부른다. 세로로 5개의 Stage가 있고, 가로로 11개의 Area가 있다. 5×11 = 55개의 칸이 있는 셈이다. 각 칸 안에 해당하는 Task들이 들어간다.

이 Matrix는 프로젝트의 지도 역할을 한다. 도시 지도에서 어느 구역에 무엇이 있는지 한눈에 볼 수 있듯이, Matrix를 보면 프로젝트 전체가 한눈에 들어온다.

## 1. Stage: 프로젝트의 시간 축

Stage는 Matrix의 세로 축이다. 프로젝트가 시간순으로 어떻게 진행되는지를 나타낸다. S1부터 S5까지, 순서대로 진행한다.

### 1-1 S1: 개발 준비

모든 것의 시작점이다. 집을 짓기 전에 기초 공사를 하듯이, 코드를 작성하기 전에 필요한 모든 기반을 구축한다.

데이터베이스 테이블을 설계하고, 인증 시스템을 설정하고, 프로젝트 구조를 잡는다. 여기서 잘못되면 나중에 전체를 뜯어고쳐야 할 수 있다. 그래서 S1에는 충분한 시간을 들여야 한다.

S1의 대표적인 Task는 "users 테이블 스키마 생성", "Supabase Auth Provider 설정", "Supabase Client 라이브러리 설정" 같은 것들이다. 눈에 보이는 기능은 아니지만, 모든 기능의 토대가 된다.

### 1-2 S2: 개발 1차

핵심 기능을 만드는 단계다. 서비스의 본질적인 기능들이 여기서 구현된다.

로그인, 회원가입, 이메일 인증 같은 사용자 인증 기능. 구독 관리, 결제 처리 같은 비즈니스 로직. 이 단계가 끝나면 서비스의 뼈대가 완성된다.

S2에는 가장 많은 Task가 집중된다. Frontend, Backend, Security가 서로 얽혀서 돌아가기 때문에 의존성 관리가 중요해진다.

### 1-3 S3: 개발 2차

고급 기능을 추가하는 단계다. S2에서 만든 기본 기능 위에 더 발전된 기능을 올린다.

AI 연동이 대표적이다. OpenAI나 Claude API를 연결해서 AI 채팅 기능을 만든다. 또는 외부 서비스를 통합해서 기능을 확장한다.

S3의 특징은 외부 API 의존성이 높다는 것이다. 외부 서비스의 API 키가 필요하고, 그 서비스의 정책을 따라야 한다.

### 1-4 S4: 개발 3차

수익화와 관리 기능을 만드는 단계다. 서비스를 운영하려면 돈을 받아야 하고, 관리할 수 있어야 한다.

결제 시스템이 핵심이다. PG사(Payment Gateway, 결제 대행 업체인 토스페이먼츠 등)와 연동해서 실제 결제가 되게 만든다. 관리자 대시보드를 만들어서 운영자가 서비스를 관리할 수 있게 한다.

S4는 보안이 특히 중요하다. 결제 정보는 민감하기 때문에 실수하면 큰 문제가 된다.

### 1-5 S5: 운영

서비스를 세상에 내놓는 단계다. 개발 환경에서 잘 돌아가는 것과 실제 운영 환경에서 돌아가는 것은 다르다.

프로덕션 배포, 도메인 연결, 모니터링 설정, 백업 체계 구축. 서비스가 24시간 안정적으로 돌아가게 만드는 모든 작업이 S5에 속한다.

S5는 한 번으로 끝나지 않는다. 서비스가 운영되는 동안 계속된다.

## 2. Area: 프로젝트의 기술 축

Area는 Matrix의 가로 축이다. 작업의 기술적 영역을 나타낸다. 11개 Area가 있고, 각각 전문 분야가 다르다.

### 2-1 M (Documentation) - 문서화

API 문서, 사용자 가이드, 개발 문서를 작성한다. 코드만큼 중요한 것이 문서다. 나중에 누군가(심지어 미래의 자신이) 코드를 이해하려면 문서가 있어야 한다.

### 2-2 U (Design) - UI/UX 디자인

사용자 인터페이스를 디자인한다. 와이어프레임을 그리고, UI 컴포넌트를 설계하고, 사용자 경험을 고민한다. 어떻게 하면 사용자가 쉽게 서비스를 이용할 수 있을지 연구한다.

### 2-3 F (Frontend) - 프론트엔드

사용자가 보는 화면을 만든다. HTML, CSS, JavaScript로 버튼, 입력창, 레이아웃을 구현한다. 사용자가 클릭하고 입력하는 모든 인터랙션이 여기서 처리된다.

Frontend 코드는 Production 폴더에 저장된다. 실제로 배포되는 코드이기 때문이다.

### 2-4 BI (Backend Infrastructure) - 백엔드 기반

백엔드의 공통 라이브러리를 만든다. Supabase Client 같은 것이 여기 속한다. 여러 API에서 공통으로 사용하는 유틸리티 함수도 BI Area에서 관리한다.

### 2-5 BA (Backend APIs) - 백엔드 API

서버 API를 구현한다. 사용자가 로그인 버튼을 누르면 Frontend에서 Backend API를 호출한다. 그 API가 실제로 로그인 처리를 하고 결과를 돌려준다.

REST API 엔드포인트, 비즈니스 로직, 데이터 처리가 모두 BA Area의 몫이다.

### 2-6 D (Database) - 데이터베이스

데이터를 저장하고 관리한다. 테이블을 설계하고, SQL 스크립트를 작성하고, 마이그레이션을 관리한다. RLS(Row Level Security) 정책도 여기서 설정한다.

Database 코드는 Production 폴더에 저장하지 않는다. Supabase에서 직접 실행하기 때문이다.

### 2-7 S (Security) - 보안/인증/인가

보안 관련 모든 것을 담당한다. 인증(Authentication)은 "누구인지 확인"하는 것이고, 인가(Authorization)는 "무엇을 할 수 있는지 확인"하는 것이다. OAuth 설정, 세션 관리, 보안 정책이 S Area에 속한다.

### 2-8 T (Testing) - 테스트

테스트 코드를 작성하고 실행한다. 단위 테스트, 통합 테스트, E2E 테스트를 만든다. 코드가 제대로 동작하는지 자동으로 검증하는 역할이다.

테스트 코드는 Production에 배포하지 않는다.

### 2-9 O (DevOps) - 운영/배포

배포와 운영 인프라를 담당한다. CI/CD 파이프라인을 설정하고, 배포 스크립트를 만들고, 모니터링을 구성한다. 서버 설정과 환경 변수 관리도 O Area에서 한다.

### 2-10 E (External) - 외부 연동

외부 서비스 API를 연동한다. OpenAI API, 토스페이먼츠 API, Resend 이메일 API 같은 것들이다. 우리가 만든 것이 아니라 다른 회사의 서비스를 가져다 쓰는 것이다.

### 2-11 C (Content System) - 콘텐츠 시스템

콘텐츠를 관리한다. 블로그 글, FAQ, 학습 콘텐츠처럼 사용자에게 보여줄 내용을 CRUD(생성, 조회, 수정, 삭제)한다. CMS(Content Management System) 기능이 여기 속한다.

## 3. Task ID가 만들어지는 원리

Matrix를 이해하면 Task ID의 의미가 명확해진다. Task ID는 Stage + Area + Level의 조합이다.

S2BA1을 분해하면 S2(Stage) + BA(Area) + 1(Level)이다. "개발 1차 단계에서, 백엔드 API 영역의, 첫 번째 작업"이라는 뜻이다.

같은 Stage, 같은 Area에 여러 Task가 있으면 Level로 구분한다. S2BA1 다음은 S2BA2, 그 다음은 S2BA3이다.

이 규칙 덕분에 Task ID만 보고도 저장 위치를 알 수 있다. S2BA1의 결과물은 `S2_개발-1차/Backend_APIs/` 폴더에 저장된다. S3E1의 결과물은 `S3_개발-2차/External/` 폴더에 저장된다.

## 4. Production에 들어가는 것과 안 들어가는 것

11개 Area 중 5개만 Production 폴더에 저장된다. 나머지 6개는 저장하지 않는다.

Frontend, Backend APIs, Backend Infrastructure, Security, External - 이 5개 Area는 실제로 서비스에 배포되는 코드다. 그래서 Production 폴더에 복사한다.

Documentation은 문서라서 배포할 필요가 없다. Design은 디자인 파일이다. Database는 Supabase에서 직접 실행하므로 코드 파일로 배포하지 않는다. Testing은 테스트 코드라 배포하지 않는다. DevOps는 설정 파일이라 별도로 관리한다. Content는 DB에 저장되므로 파일로 배포하지 않는다.

## 5. Matrix로 보는 프로젝트 진행 상황

Matrix의 진짜 힘은 진행 상황을 한눈에 볼 수 있다는 것이다.

S1의 모든 칸이 완료 표시가 되어 있고, S2의 일부 칸이 진행 중이고, S3 이후는 아직 대기 상태라면, 프로젝트가 어디쯤 와 있는지 즉시 알 수 있다.

또한 같은 Stage 내의 다른 Area 작업은 병렬로 진행할 수 있다는 것도 Matrix로 파악된다. S2 단계에서 Frontend 작업과 Backend 작업이 서로 의존하지 않는다면 동시에 진행할 수 있다.

병목도 보인다. 어떤 칸이 빨간색(지연)이면 그 Area가 전체 진행을 막고 있다는 뜻이다. 자원을 집중 투입해야 할 곳을 Matrix가 알려준다.

## 6. 다음 단계

3편에서는 5×11 Matrix의 구조를 살펴봤다. 5개 Stage가 프로젝트의 시간 흐름을, 11개 Area가 기술 영역을 나타낸다. 이 둘이 만나서 55개의 칸이 생기고, 각 칸에 Task들이 배치된다.

다음 편에서는 실제로 Task를 생성하고 의존성을 관리하는 방법을 살펴본다. Task들이 서로 어떻게 연결되는지, 어떤 순서로 작업해야 하는지 알아보자.

---

*다음 편: 4편 | Task 생성과 의존성 관리*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 4,200자 / 작성자: Claude / 프롬프터: 써니**
