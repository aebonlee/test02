# 11편 | AI 작업 6대 규칙

---

AI는 시키는 대로 한다. 문제는 "시키는 대로"가 매번 다르다는 것이다.

오늘은 파일 이름을 camelCase로 지었다. 내일은 kebab-case로 지었다. 어떤 파일은 Stage 폴더에만 저장하고, 어떤 파일은 Production에도 복사했다. 일관성이 없으면 프로젝트가 엉망이 된다.

SAL Grid에서는 이 문제를 6대 규칙으로 해결한다. 여섯 개의 규칙 파일이 있고, 모든 작업은 이 규칙을 따른다. AI가 "이번에는 어떻게 하지?"를 고민할 필요가 없다. 규칙을 읽고 따르면 된다.

## 1. 규칙 파일의 위치

규칙 파일들은 .claude/rules/ 폴더에 있다. 6개의 마크다운 파일이다.

01_file-naming.md는 파일 명명 규칙이다. 02_save-location.md는 저장 위치 규칙이다. 03_area-stage.md는 Area와 Stage 매핑이다. 04_grid-writing-supabase.md는 Grid 작성 규칙이다. 05_execution-process.md는 실행 프로세스다. 06_verification.md는 검증 규칙이다.

이 파일들은 번호 순서로 정렬되어 있다. 파일 이름부터 저장 위치, 구조 매핑, Grid 작성, 실행, 검증까지. 작업 흐름에 맞게 배치되어 있다.

## 2. 규칙 1: 파일 명명

파일 이름을 어떻게 지을 것인가. 간단한 문제 같지만 의외로 혼란이 많다.

SAL Grid에서는 kebab-case를 사용한다. 소문자와 하이픈으로만 구성된다. google-login.js, subscription-cancel.js, forgot-password.html 같은 형식이다.

camelCase(googleLogin.js)나 snake_case(google_login.js)는 사용하지 않는다. 왜? 일관성 때문이다. 하나의 규칙을 정해두면 모든 파일이 같은 형식을 따른다.

파일 이름은 기능과 동작으로 구성된다. google-login에서 google은 기능이고 login은 동작이다. 파일 이름만 보고 무슨 기능인지 알 수 있다.

Task ID는 파일 이름에 넣지 않는다. 대신 파일 상단에 주석으로 넣는다. @task S2BA1처럼. 이렇게 하면 파일 이름은 깔끔하게 유지되면서도 어떤 Task의 결과물인지 추적할 수 있다.

## 3. 규칙 2: 저장 위치

파일을 어디에 저장할 것인가. 이것도 규칙이 필요하다.

SAL Grid에서는 5개 Area(F, BA, S, BI, E)의 파일을 Stage 폴더에 저장한다. Stage가 원본이다. git commit을 하면 Pre-commit Hook이 자동으로 루트 폴더(배포용)에 복사한다. 수동으로 두 곳에 저장할 필요가 없다. Stage에만 저장하면 나머지는 자동화가 처리한다. 나머지 6개 Area는 배포가 필요 없으므로 자동 복사 대상이 아니다. (상세한 이유는 3편 참조)

## 4. 규칙 3: Area와 Stage 매핑

Task ID를 보면 저장 위치가 결정된다. S2BA1은 S2 Stage의 BA Area다. 파일은 S2_개발-1차/Backend_APIs/ 폴더에 저장된다.

11개 Area와 5개 Stage의 조합으로 폴더 위치가 결정된다. (각 Area와 Stage의 상세 정의는 3편 참조)

이 매핑을 알면 Task ID만 보고도 파일이 어디에 있어야 하는지 바로 알 수 있다. S3E1은 S3_개발-2차/External/ 폴더다. 헷갈릴 일이 없다.

## 5. 규칙 4: Grid 작성

SAL Grid의 22개 속성을 어떻게 작성할 것인가. 누가 어떤 속성을 채우는지 정해져 있다.

기본 정보와 Task 정의는 설계 시점에 채운다. 프로젝트를 기획할 때 Task ID, Task 이름, Instruction, 담당 Agent 등을 정의한다.

Task 실행 결과는 작업 중에 Main Agent가 채운다. 진행률, 상태, 생성된 파일 목록, 소요 시간 같은 것들이다.

검증 결과도 Main Agent가 채운다. 하지만 검증을 수행하는 것은 Verification Agent다. Task Agent와 Verification Agent는 반드시 다른 에이전트여야 한다. 자기 작업을 자기가 검증하면 객관성이 떨어지기 때문이다.

Stage Gate 상태는 PO가 채운다. AI 검증이 끝나도 PO가 직접 테스트하고 승인해야 다음 Stage로 넘어갈 수 있다.

## 6. 규칙 5: 실행 프로세스

Task 작업은 6단계로 진행된다.

1단계는 Task 실행이다. Main Agent가 직접 하지 않고 Task Agent 서브에이전트를 투입한다. 서브에이전트가 코드를 작성하고 파일을 생성한다.

2단계는 PO 도움 요청이다. 외부 서비스 설정이 필요하면 이 시점에 요청한다. 작업 다 끝나고 "아, 이거 설정해야 해요"라고 하면 안 된다.

3단계는 Task 검증이다. Verification Agent 서브에이전트를 투입해서 결과물을 검증한다. Task Agent와 다른 에이전트가 검증해야 한다.

4단계는 Stage Gate 검증이다. Stage의 모든 Task가 완료되면 Main Agent가 전체를 검증한다.

5단계는 PO 테스트 가이드 제공이다. AI 검증이 끝나면 PO가 직접 테스트할 수 있도록 가이드를 만들어 제공한다.

6단계는 PO 최종 승인이다. PO가 직접 테스트하고 문제가 없으면 승인한다. 승인을 받아야 다음 Stage로 넘어갈 수 있다.

## 7. 규칙 6: 검증

검증은 여러 측면에서 이루어진다.

테스트 검증에서는 단위 테스트, 통합 테스트, 엣지 케이스, 수동 테스트를 확인한다. 빌드 검증에서는 컴파일, 린트, 배포, 런타임 에러를 확인한다. 통합 검증에서는 의존성 전파, 다른 Task와의 연결, 데이터 흐름을 확인한다.

Blocker가 있는지도 확인한다. 선행 Task가 미완료인지, 환경 설정이 안 됐는지, 외부 API에 문제가 있는지.

모든 검증을 종합해서 최종 판정을 내린다. Passed면 통과, Failed면 수정이 필요하다.

Human-AI Task는 추가 기준이 있다. 외부 서비스 설정이 필요한 Task는 AI가 가이드만 작성한다고 끝이 아니다. PO가 실제로 설정을 하고, 실제로 작동하는지 테스트해야 완료로 인정된다.

## 8. 규칙 적용 방법

Order Sheet에 rules_reference 필드가 있다. 이 필드에 참조해야 할 규칙 파일을 나열한다.

AI는 Order Sheet를 받으면 먼저 rules_reference를 확인한다. 해당 규칙 파일들을 읽는다. 그리고 규칙에 맞게 작업을 수행한다.

모든 Task에는 기본적으로 파일 명명 규칙, 저장 위치 규칙, 실행 프로세스 규칙이 적용된다. 이중 저장이 필요한 Area라면 Area/Stage 매핑 규칙도 추가된다. 검증이 필요하면 검증 규칙도 추가된다.

이렇게 규칙을 참조하면 일관된 품질이 보장된다. 어떤 세션에서 어떤 AI가 작업하든 같은 규칙을 따르니까 결과물의 형식이 통일된다.

## 9. 다음 단계

11편에서는 AI 작업 6대 규칙을 살펴봤다. 파일 명명, 저장 위치, Area/Stage 매핑, Grid 작성, 실행 프로세스, 검증. 이 여섯 가지 규칙이 일관된 품질을 보장한다.

다음 편에서는 Orders/Reports JSON 시스템을 살펴본다. Order와 Report의 구체적인 JSON 구조와 활용법이다.

---

*다음 편: 12편 | Orders/Reports JSON 시스템*

---

**작성일: 2025-12-20 / 수정일: 2025-12-20 / 글자수: 약 3,400자 / 작성자: Claude / 프롬프터: 써니**
