【발명의 명칭】
【국문명】
3차원 좌표계(Stage-Area-Level)가 인코딩된 식별자 기반으로 구축하는 프로젝트 그리드를 활용한 멀티태스크 오케스트레이션 시스템 및 방법
【영문명】
Multi-Task Orchestration System and Method Utilizing Project Grid Constructed Based on Identifiers Encoding 3D Coordinate System (Stage-Area-Level)

【기술분야】
본 발명은 프로젝트의 단계(Stage), 영역(Area), 계층(Level)을 나타내는 3차원 좌표 정보가 인코딩된 식별자(이하 "SAL(Stage-Area-Level) ID"라 한다)를 기반으로, 복수의 속성으로 구성된 프로젝트 그리드(이하 "SAL Grid"라 한다)를 구축하고, 이를 활용하여 멀티태스크를 오케스트레이션하는 시스템 및 방법과 관련된 것이다.

본 발명은 국제특허분류(IPC) 기준으로 G06F 9/46(다중 프로그래밍 배열), G06F 9/48(프로그램 실행 제어), G06Q 10/06(자원, 워크플로우 및 프로젝트 관리) 분야에 해당한다.

본 명세서에서 Stage(단계), Area(영역), Level(계층), Variant(병렬 분기), Task(작업) 등 핵심 개념은 국제적 이해와 명확성을 위해 영문 표기를 사용한다.

본 발명의 핵심은 종래 기술에서 사용되는 간트 차트(Gantt Chart), 작업 리스트, 그래프(DAG) 수동 코딩 등의 방식과 달리, "3차원 좌표가 인코딩된 식별자(SAL ID)를 기반으로 프로젝트 그리드(SAL Grid)를 구축하는 방식"을 제안하는 점에 있다. 이를 통해 Task 지시서 및 검증 지시서의 자동 생성, 3D 시각화, SAL ID 변경 이력 추적(ID Chain)을 가능하게 한다.

【발명의 배경이 되는 기술】
본 발명이 속하는 기술 분야의 종래 기술은 다음과 같이 분류된다.

가) 워크플로우 오케스트레이션
워크플로우 오케스트레이션(Workflow Orchestration)은 복수의 작업(Task) 간의 의존 관계를 자동 실행 및 관리하는 기술이다. Apache Airflow, Prefect, Temporal 등이 대표적이며, 이들은 주로 DAG(Directed Acyclic Graph)를 핵심 시스템 구조로 사용한다. 사용자가 코드(Python 등)로 명시적으로 코딩하면, 이들이 이를 파싱하여 스케줄링하고 실행하는 구조를 갖는다.

나) 프로젝트 관리 도구
Jira, Asana, Monday.com, Microsoft Project 등의 프로젝트 관리 도구는 작업을 리스트(List), 칸반(Kanban), 간트 차트(Gantt Chart) 형태로 관리한다. 이들 도구에서 사용하는 식별자(예: PROJECT-1234)는 순차적으로 부여되는 단순 참조 번호로서, 작업의 계층적 구조나 관리 정보를 포함하지 않는다.

다) 의존성 관리 기법
CPM(Critical Path Method)과 PERT(Program Evaluation and Review Technique)는 작업 간 의존 관계를 분석하고 주요 경로(Critical Path)를 식별하여 프로젝트 일정을 최적화하는 기법이다. 이들은 네트워크 다이어그램을 통해 작업 간 선후 관계를 표현하지만, 식별자 자체에 구조 정보를 인코딩하지는 않는다.

라) 비즈니스 프로세스 관리(BPM)
Camunda, Flowable 등의 BPM 시스템은 BPMN(Business Process Model and Notation) 표준을 사용하여 비즈니스 프로세스를 모델링하고 실행한다. 프로세스 플로우를 시각적으로 설계할 수 있으나, 대규모 프로젝트의 다차원 구조를 표현하는 데 한계가 있다.

마) 좌표 기반 시각화
3차원 좌표계는 CAD, GIS, 게임 엔진 등에 객체의 공간적 위치를 표현하는 데 널리 사용된다. 과거 유사 기술 연구에서는 다중 프로젝트 스케줄링을 위해 3차원 간트 차트를 제안하기도 하였으나, 이는 시각화 목적에 한정되며 식별자 자체에 시스템적 자동 구조 추출과는 무관하다.

【선행기술문헌】
【특허문헌】
(미국)
· US 12,248,810 B2: DAG를 활용한 컴퓨터화된 워크플로우 자동 스케줄링
· US 10,248,442 B2 (Airbnb): DAG를 동적으로 생성하는 방법
· US 10,521,270 B2 (Google): 분산 처리 시스템에서 관리 태스크
· US 7,577,554 B2: 비순환 방향 그래프 시스템 구조를 활용한 워크플로우 모델링 기법
· US 6,101,481 A: 복수 자원의 작업을 조정하는 작업 관리 태스크

(유럽)
· EP 4,064,609 A1: 블록체인 기반 방향성 비순환 그래프(DAG) 시스템 구조의 코드 공유

(한국)
· KR 10-2184182 B1: 컴퓨터 관리 기반 프로젝트/작업 지능형 목표 관리 및 방법 시스템
· KR 10-1662998 B1: 동적 비즈니스 프로세스 관리 태스크
· KR 10-2021-0056789 A: 블록체인 기반 시스템 무결성 검증 태스크

【비특허문헌】
· Cruz, R. et al. (2021), "Managing Data Pipeline with Apache Airflow", IJARSCT
· Krishna, S. et al. (2020), "Apache Airflow: A Survey and Best Practices"
· Herbst, J. et al. (2020), "Evaluation of Workflow Management Systems: A Case Study with Apache Airflow"
· 3D 좌표계 기반 프로젝트 스케줄링 연구 (ResearchGate, 2019)

【선행기술과의 차별성】
본 발명은 상기 선행기술들과 다음과 같은 본질적인 차이를 갖는다.

첫째, Apache Airflow(US 12,248,810 B2) 등 워크플로우 오케스트레이션 시스템과의 차별성이다. Apache Airflow는 사용자가 파이썬(Python) 코드를 사용하여 DAG(Directed Acyclic Graph) 구조를 명시적으로 작성해야 하며, 이는 각 Task 간의 의존 관계를 `task_a >> task_b` 형태로 코딩하는 프로그래밍 기반 접근 방식이다. 사용자는 복잡한 워크플로우를 표현하기 위해 반복문, 조건문, 함수 정의 등 고급 프로그래밍 지식을 필요로 하며, 의존성 구조 변경 시 코드를 직접 수정하고 디버깅해야 한다. 반면, 본 발명의 SAL ID 기반 시스템은 복잡한 코드 작성 없이 식별자 자체에 3차원 좌표(Stage, Area, Level)가 인코딩되어 있어, 파서(40)가 정규식 파싱만으로 의존성 구조를 자동으로 추론하고 구축한다. 예를 들어, `S2A1L1`이라는 SAL ID는 파싱 즉시 "Stage 2, Area A1, Level 1"로 분해되어, 동일 Stage와 Area 내에서 Level 값이 작은 Task가 자동으로 선행 작업임을 시스템이 인지한다. 또한, 본 발명의 시퀀서(53)는 Level 충돌을 자동 감지하여 SAL ID를 동적으로 조정하고, 이를 참조하는 모든 Task의 dependency 필드를 자동 갱신함으로써, Apache Airflow에서 수동으로 수행해야 하는 DAG 재작성 과정을 완전 자동화한다. Apache Airflow의 식별자는 `task_id`라는 단순 문자열로서 구조 정보를 포함하지 않으나, 본 발명의 SAL ID는 식별자 자체가 3차원 좌표계의 위치 정보를 내재하여 별도의 매핑 테이블 조회 없이 즉시 작업의 위치와 맥락을 파악할 수 있다.

둘째, Jira, Asana 등 프로젝트 관리 도구와의 차별성이다. 이들 도구의 식별자(예: PROJECT-1234, ISSUE-5678)는 데이터베이스의 자동 증가(Auto-increment) 필드로 생성되는 순차적 참조 번호로서, 해당 작업이 어느 단계(Stage)와 영역(Area)에 속하는지에 대한 정보가 전혀 포함되지 않는다. 사용자는 작업의 위치를 파악하기 위해 별도의 필터, 태그, 커스텀 필드를 조회해야 하며, 이는 추가적인 인지 부하를 발생시킨다. 반면, 본 발명의 SAL ID는 식별자 자체가 `S{stage}{area}{level}{variant?}` 형식으로 구성되어, 예를 들어 `S3BA2`는 "Stage 3의 Backend APIs 영역, Level 2 작업"임을 즉시 알 수 있다. 또한, Jira 등에서 작업의 속성이 변경되면 기존 Issue 번호가 그대로 유지되어 변경 전후 맥락이 혼재되거나, 또는 새 Issue를 생성하면서 기존 Issue와의 연결이 끊어지는 참조 무결성 문제가 발생한다. 본 발명은 SAL ID 변경 시 기존 ID를 삭제하지 않고 새로운 ID를 체인 방식으로 연결하는 Append-Only 구조를 채택하여, 구(Old) SAL ID로 조회해도 리졸버(74)가 체인을 추적하여 최신 SAL ID를 자동 반환함으로써 참조 무결성을 자가 치유(Self-Healing)한다.

셋째, 3차원 간트 차트 연구(ResearchGate, 2019)와의 차별성이다. 해당 선행 연구는 다중 프로젝트 스케줄링을 위해 X축을 시간, Y축을 프로젝트 번호, Z축을 자원으로 설정한 3차원 시각화 방법을 제안하였으나, 이는 시각화(Visualization)에만 국한된 개념적 제안이다. 식별자 자체에 좌표 정보가 인코딩되어 있지 않고, 파싱을 통한 자동 의존성 추론, Task 지시서 자동 생성, 검증 자동화, ID 체인 관리 등 시스템적 오케스트레이션 메커니즘이 부재하다. 본 발명은 단순 시각화를 넘어서, SAL ID를 파싱하여 자동으로 Task 지시서 및 검증 지시서를 생성하는 SAL 그리드 생성기(52), Level 충돌을 감지하여 SAL ID를 동적 조정하는 시퀀서(53), 에이전트와 도구를 자동 배정하는 배분기(54), Task 실행 및 검증 결과를 실시간 기록하는 SAL 그리드 레코더(60), ID 변경 이력을 체인으로 관리하는 ID 체인 관리 모듈(70), 그리고 3차원 좌표(Stage-X축, Area-Y축, Level-Z축)로 매핑하여 실시간 프로젝트 진행 현황을 시각화하는 SAL 그리드 뷰어(60)를 포함하는 완전한 통합 오케스트레이션 시스템을 구성한다. 또한, 본 발명은 Stage별로 전체 Task의 완료 여부, 빌드 및 테스트 통과 여부, 의존성 체인 완결성을 검증하는 자동 검증 리포트 생성 및 Stage Gate 승인 프로세스를 포함하며, 승인이 거절될 경우 자동으로 Task 실행 단계로 회귀하는 피드백 루프를 내장하여 실행-검증-기록-승인의 순환적 오케스트레이션 사이클을 완성한다.

넷째, BPM(Business Process Management) 시스템과의 차별성이다. Camunda, Flowable 등 BPM 시스템은 BPMN 표준을 사용하여 비즈니스 프로세스 플로우를 시각적으로 설계하고 실행할 수 있으나, 프로세스 정의는 XML 또는 그래픽 모델링 도구를 통해 수동으로 작성되어야 하며, 식별자는 프로세스 인스턴스 번호로서 구조 정보를 포함하지 않는다. 또한, BPM 시스템은 주로 반복적인 비즈니스 워크플로우 자동화에 최적화되어 있어, 프로젝트별로 고유한 구조와 의존성을 갖는 일회성 프로젝트 오케스트레이션에는 적합하지 않다. 본 발명은 프로젝트별로 고유한 Stage-Area-Level 구조를 SAL ID에 인코딩하고, 이를 파싱하여 프로젝트 SAL 그리드를 자동 구축함으로써, 반복적 워크플로우뿐만 아니라 소프트웨어 개발, 제조, 건설, 회계감사, 영화 제작 등 각기 다른 구조와 요구사항을 갖는 일회성 대규모 프로젝트에 범용적으로 적용 가능한 유연한 오케스트레이션 프레임워크를 제공한다. 또한, BPM 시스템의 프로세스 인스턴스 ID는 실행 순번일 뿐이나, 본 발명의 SAL ID는 Stage-Area-Level 구조 정보를 내재하여 ID 자체만으로 작업의 위상(Topology)을 즉시 파악할 수 있다.

그러나 상기 선행기술들은 다음과 같은 한계와 문제점들을 갖는다.

가) 코딩 의존성 및 정적 관리의 한계
Apache Airflow 등 워크플로우 도구는 의존성(DAG)을 정의하기 위해 파이썬(Python) 등으로 복잡한 코드를 직접 작성해야 하므로, 비개발자인 프로젝트 관리자가 접근하기 어렵고 수정 시마다 코드 레벨의 디버깅이 필요한 진입 장벽이 존재한다. 또한, CPM/PERT와 같은 전통적 기법은 계획 수립에는 유용하나, 실제 작업 실행(Execution) 결과와 실시간으로 연동되지 않는 정적 분석에 그치는 한계가 있어 동적인 프로젝트 상황 변화에 민첩하게 대응하기 어렵다.

나) 식별자의 구조 정보 부재
Jira, Asana, BPM 시스템 등에서 사용하는 식별자(예: PROJECT-1234)는 순차적으로 부여되는 단순 참조 번호에 불과하다. 이 식별자에는 Stage, Area, Level 등 구조 정보가 포함되어 있지 않아, 식별자만으로는 해당 작업이 어느 공정 단계(Stage)와 업무 영역(Area)에 속하는지 직관적으로 알 수 없어, 별도의 매핑 테이블을 조회하거나 메타데이터를 일일이 확인해야 하는 비효율이 발생한다.

다) 변경 관리 및 참조 무결성 문제
프로젝트 진행 중 작업의 속성이나 위치가 변경될 경우, 기존 식별자가 무효화되거나 참조 링크가 깨지는 '참조 무결성(Referential Integrity)' 위반 문제가 빈번히 발생한다. 또한, 변경 이력을 별도의 텍스트 로그로만 관리하여, 특정 시점의 프로젝트 상태(Snapshot)를 온전히 재구성하거나 변경 원인을 역추적하는 데 많은 비용과 시간이 소요된다.

라) 다차원 구조 표현 및 제어의 한계
기존의 2D 간트 차트나 리스트 뷰는 시간(Stage)과 작업명 정도만 표현할 뿐, Stage, Area, Level, Variant 등 4차원 이상의 복합 정보를 평면상에 동시에 표현하기 어렵다. 이로 인해 수천 개의 작업이 얽힌 대규모 프로젝트에서는 전체 구조(Overview)와 작업 간 유기적 관계를 직관적으로 파악하는 데 심각한 인지적 과부하(Cognitive Overload)와 병목이 발생한다.

마) Task 실행과 검증의 분리
종래 기술에서는 Task 실행(Execution)과 품질 검증(Verification)이 별개의 도구와 프로세스로 분절되어 운영되어, Task 완료 후 검증 절차가 자동으로 이어지지 않는 경우가 많다. 이로 인해 검증 누락이나 피드백 지연이 발생하고, '실행-검증-기록-승인'으로 이어지는 체계적인 오케스트레이션 사이클이 부재하여 프로젝트 품질 관리에 허점이 발생한다.




【해결하려는 과제】
본 발명은 상기 종래 기술의 문제점들을 해결하기 위해 고안된 것으로서, 다음과 같은 기술적 과제를 해결하고자 한다.

가) 수동 DAG 코딩의 복잡성 및 진입 장벽
종래 기술에서 워크플로우 구조(DAG)를 정의하기 위해 고숙련 개발자의 복잡한 코딩이 요구되는 문제를 해결하고자 한다. 본 발명은 SAL ID를 파싱하는 것만으로 복잡한 의존성 구조를 자동으로 추론하고 구축하는 No-Code/Low-Code 방식을 제공하여, 비전문가도 쉽게 대규모 프로젝트를 오케스트레이션할 수 있도록 한다.

나) 구조 정보가 내재된 식별자의 부재로 인한 비효율
종래 기술의 식별자는 단순 참조 번호에 불과하여 식별자만으로 작업의 위치나 맥락을 파악할 수 없다. 본 발명은 3차원 좌표 정보 자체가 인코딩된 새로운 형식의 식별자(SAL ID)를 제안함으로써, 별도의 매핑 테이블 조회 없이 식별자만으로 작업의 위치, 맥락, 의존 관계를 즉시 파악할 수 있는 체계를 제공하고자 한다.

다) 참조 무결성 위반 및 이력 추적의 난해함
작업 변경 시 기존 식별자가 무효화되거나 링크가 깨지는 문제를 해결하고, 단순 로그가 아닌 체계적인 이력 관리 시스템을 제공하고자 한다. 본 발명은 변경 이력을 Append-Only 체인으로 관리하고, 구(Old) ID로도 최신 작업 내용을 투명하게 조회할 수 있는 자가 치유(Self-Healing) 매커니즘을 구현한다.

라) 평면적/선형적 모델의 구조적 한계 및 다차원 의존성 표현 불가
기존의 2D 리스트나 간트 차트는 복잡한 프로젝트의 입체적인 위상(Topology)을 평면적으로 억지 병합(Flatten)해야 하는 근본적 한계가 있다. 이로 인해 작업 간의 입체적인 전후/상하 의존 관계(Spatial Dependency)가 소실되고, 프로젝트의 논리적 구조를 온전히 담아내거나 제어하지 못하는 문제가 발생한다.

마) 실행과 검증 프로세스의 단절
실행(Execution)과 검증(Verification)이 분리되어 발생하는 품질 저하 문제를 해결하고자 한다. 본 발명은 모든 Task 완료 시 자동으로 검증 절차를 트리거하고 그 결과를 기록하며, Stage 단위의 최종 승인 없이는 다음 단계로 넘어가지 못하게 하는 강제적 피드백 루프를 내장하여 프로세스의 완결성을 보장한다.

【과제의 해결 수단】
본 발명은 상기 과제를 해결하기 위해, 다음과 같은 수단을 제공한다.

가) SAL ID 기반 프로젝트 그리드 구축 (No-Code Automation)
본 발명은 SAL ID를 파싱하는 것만으로 복수의 속성으로 구성된 프로젝트 그리드(SAL Grid)를 자동 구축한다. 파서(40)가 SAL ID를 검증하고, SAL 그리드 생성기(52)가 Task 지시서 및 검증 지시서를 동시에 생성하여, 복잡한 코딩(DAG) 없이도 의존성 구조를 완성한다.

나) 3차원 좌표가 인코딩된 식별자 (SAL ID)
본 발명의 SAL ID는 Stage-Area-Level-Variant의 4개 세그먼트로 구성되어 3차원 좌표 정보가 식별자 자체에 인코딩된다. 이를 통해 식별자만으로 해당 Task의 프로젝트 내 위치, 맥락, 의존 관계를 즉시 파악할 수 있다.

다) 실행-검증-기록-승인의 순환 오케스트레이션 사이클
본 발명은 계획 수립 → SAL ID 생성 → 그리드 구축 → Task 실행 → 검증 수행 → 결과 기록 → Stage 검증 → 보고서 생성 → Stage 승인의 9단계 순환 사이클을 제공한다. 각 Task 완료 시 자동으로 검증이 트리거되고 결과가 기록된다.

라) SAL ID 변경 이력 추적 및 자동 해석 (ID Chain)
본 발명은 ID Chain을 통해 SAL ID 변경 이력을 Append-Only 방식으로 보존한다. 리졸버(74)가 이전 SAL ID로 조회 시 체인을 순회하여 최신 SAL ID를 자동으로 반환함으로써, 참조 링크가 깨지지 않는 자가 치유(Self-Healing) 메커니즘을 제공한다.

마) 3차원 공간 좌표계 기반의 오케스트레이션 위상(Topology) 제공
본 발명은 단순한 시각화를 넘어, Stage(단계)-Area(영역)-Level(위계)의 3차원 좌표계를 프로젝트의 논리적 기반(Logical Foundation)으로 활용한다. 이 3차원 그리드 공간 내에서의 좌표(Position)가 해당 작업의 논리적 위치와 의존 관계를 정의하며, 이를 기반으로 시퀀서(53)와 배분기(54)가 실행 순서, 우선순위, 자원 할당을 결정한다. 이를 통해 평면적 모델이 해결하지 못하는 고차원의 복잡성을 체계적으로 제어한다.

바) 정규식 기반 SAL ID 검증 및 오류 격리
본 발명의 파서(40)는 정규식을 통해 SAL ID의 유효성을 검증하고, 유효하지 않은 ID는 Unassigned Queue(46)로 이동시켜 시스템 흐름을 중단하지 않고 별도 관리한다.

사) 시퀀서 및 배분기를 통한 자동 조정
시퀀서(53)가 작업 내용을 분석하여 실행 순서를 자동 조정하고, 배분기(54)가 각 Task에 적합한 에이전트와 도구를 자동으로 배분한다.

아) SAL 그리드 레코더를 통한 실시간 기록
SAL 그리드 레코더(60)는 Task 실행 및 검증 수행 결과(진행 상태, 소요 시간, 산출물, 테스트 통과 여부)를 실시간으로 기록한다.

자) Stage 승인 거절 시 피드백 루프
본 발명은 Stage 승인이 거절될 경우 Task 실행 단계로 자동 회귀하여 수정 작업을 수행하는 피드백 루프를 내장하고 있다.

【발명의 효과】
본 발명은 이러한 프로세스를 통해 다음과 같은 효과를 제공한다.

가) No-Code 기반의 즉각적 그리드 구축
SAL ID를 파싱하는 것만으로 복잡한 의존성 구조(DAG)와 검증 지시서를 포함하는 전체 프로젝트 그리드가 자동 구축된다. 이는 고숙련 엔지니어의 코딩 없이도 대규모 오케스트레이션 시스템을 즉시 운용할 수 있게 하여, 도입 비용과 시간을 획기적으로 절감한다.

나) 식별자의 자기 설명성 및 구조적 내재화
SAL ID는 그 자체로 작업의 3차원 좌표를 표현하므로, 별도의 조회 없이 식별자만으로 작업의 위치, 맥락, 의존 관계를 즉시 파악할 수 있다. 이를 통해 시스템 내 어느 모듈에서든 SAL ID만으로 작업을 식별하고 처리할 수 있어, 작업 관리의 일관성과 효율성이 향상된다.

다) 3차원 그리드 위상(Topology) 기반의 정밀한 실행 제어
본 발명의 3차원 SAL 그리드는 단순한 시각화 데이터가 아니라, 멀티태스크 오케스트레이션 시스템 전체의 실행을 제어하는 논리적 기반(Logical Foundation)으로서 기능한다. Stage(단계)-Area(영역)-Level(위계)의 좌표계는 작업 간의 선후 관계, 병렬 실행 가능성, 의존 관계를 정의하는 수학적 위상(Topology)을 제공하며, 이를 기반으로 시퀀서와 배분기가 수만 개의 복잡한 태스크를 충돌 없이 정밀하게 제어할 수 있다.

라) 실행과 검증의 일체화 (Quality Assurance Loop)
Task 실행과 동시에 검증이 트리거되는 강결합 프로세스를 통해, '선행 작업 검증 완료 시 후행 작업 시작'이라는 품질 원칙을 시스템적으로 강제한다. 이는 결함의 전파를 원천 차단하고 최종 산출물의 무결성을 보장한다.

마) 참조 무결성 및 자가 치유(Self-Healing)
Append-Only 방식의 ID 체인을 통해, 프로젝트 구조가 변경되더라도 기존 참조가 끊기지 않고 최신 상태로 자동 연결되는 강력한 내구성을 제공한다.

바) 입력 유효성 검증을 통한 시스템 안정성 확보
정규식 기반의 SAL ID 검증 및 Unassigned Queue를 통한 오류 격리로, 잘못된 입력이 시스템 전체의 흐름을 중단시키지 않고 별도로 관리되어 시스템의 연속 운영이 보장된다.

사) 시퀀서 및 배분기를 통한 실행 최적화
시퀀서가 작업 내용을 분석하여 최적의 실행 순서를 자동 산출하고, 배분기가 각 Task에 가장 적합한 에이전트와 도구를 자동 배분함으로써, 수동 조율 없이도 효율적인 자원 활용이 가능해진다.

아) 실시간 진행 상황 기록 및 가시성 확보
SAL 그리드 레코더가 Task 실행 및 검증 결과(진행 상태, 소요 시간, 산출물, 통과 여부)를 실시간으로 기록하여, 프로젝트 관리자가 언제든지 정확한 현황을 파악하고 신속한 의사결정을 내릴 수 있는 가시성을 제공한다.

【도면의 간단한 설명】
【도 1】 본 발명의 실시예에 따른 멀티태스크 오케스트레이션 시스템의 전체 구성도
【도 2】 본 발명의 3차원 SAL 그리드 좌표계의 개념도 (Stage-Area-Level 축)
【도 3】 본 발명의 핵심인 SAL ID(식별자 코드)의 구조도 (Stage, Area, Level, Variant 세그먼트)
【도 4】 본 발명의 파서 모듈(40) 동작 흐름도 (SAL ID 파싱 프로세스)
【도 5】 본 발명의 SAL 그리드 생성 프로세스 흐름도 (복수의 속성 그리드 구축)
【도 6】 본 발명의 SAL 그리드 기록 및 뷰어 시스템 구조도
【도 7】 본 발명의 SAL ID 체인 모듈 구조도 (변경 이력 관리)
【도 8】 본 발명의 멀티태스크 오케스트레이션 시스템 순환 운영주기 (9단계 프로세스)

【발명을 실시하기 위한 구체적인 내용】
이하, 첨부 도면을 참조하여 본 발명의 바람직한 실시예를 상세히 설명한다.

1. 전체 시스템 구성 (도 1 관련)
도 1은 본 발명의 실시예에 따른 멀티태스크 오케스트레이션 시스템의 전체 구성도를 도시한다.

1.1 5계층 아키텍처
도 1을 참조하면, 본 시스템은 다음의 5개 계층으로 구성된다:

계층 1: 입력 계층
SAL ID 생성 모듈(30)이 프로젝트 작업을 식별하는 고유 식별자를 생성한다. 이 모듈은 사용자 입력 또는 자동 생성 규칙에 따라 SAL ID를 산출한다.

계층 2: 엔진 계층
파서 모듈(40)은 입력된 SAL ID를 파싱하여 Stage, Area, Level 좌표를 추출하고 정규화한다. SAL 그리드 생성기(52)는 파싱된 정보를 바탕으로 Task 지시서 및 검증 지시서를 생성한다. 시퀀서(53)는 Task 내용을 분석하여 실행 순서의 문제를 파악하고 순서를 조정하여 Level 값을 변경함으로써 SAL ID를 조정하고 변경된 SAL ID를 dependency 필드에서 참조하는 Task들의 의존성 정보를 갱신하며, 배분기(54)는 적절한 에이전트와 도구를 자동으로 배분한다.

계층 3: SAL 그리드 계층
기본 정보(51)와 지시서(52)를 바탕으로 Task 실행(84) 및 검증 수행(85)이 진행된다. SAL 그리드 레코더(60)는 실행 및 검증 결과를 실시간으로 기록하며, Stage 검증(87) 단계에서 해당 단계 전체의 완료 여부를 종합적으로 검증한다.

계층 4: 이력 관리 계층
SAL ID 체인 모듈(70)은 SAL ID 변경 이력을 블록체인 스타일의 Append-only 체인으로 관리한다. 이를 통해 모든 변경 사항이 삭제되지 않고 보존되며, 과거 상태를 추적할 수 있다.

계층 5: 출력 계층
SAL 그리드 뷰어(63)는 프로젝트 진행 상황을 Stage(X), Area(Y), Level(Z)의 3차원 공간으로 시각화한다. Stage 검증 리포트(88)는 각 단계의 완료 현황, 차단 요소, 품질 지표를 포함하는 종합 리포트를 자동 생성한다.

1.2 데이터 흐름
시스템 내 주요 데이터 흐름은 다음과 같다:
- SAL ID 생성(30) → 파서(40): 식별자 전달
- 파서(40) → 그리드 생성기(52) → 시퀀서(53) → 배분기(54): 순차적 처리
- 엔진 계층 → SAL 그리드 계층: 그리드 구축 및 실행
- 그리드 계층 → 레코더(60) → 뷰어(63): 결과 기록 및 시각화
- 모든 변경 사항 → ID 체인(70): 이력 보존

2. SAL 그리드 좌표계 (도 2 관련)
도 2는 본 발명의 핵심 기반이 되는 SAL 그리드 좌표계의 개념도를 도시한다.

본 발명의 SAL 그리드(20)는 Stage, Area, Level의 3개 직교 축으로 정의되는 3차원 좌표 공간이다. 이 좌표계는 프로젝트의 모든 작업을 공간적으로 배치하고, 작업 간의 관계를 직관적으로 표현할 수 있는 기반을 제공한다.

도 2를 참조하면, SAL 그리드(20)는 3개의 직교 축으로 정의되는 3차원 좌표 공간이다.

2.1 Stage 축 (21) - X축
Stage(X축)는 프로젝트의 개발 진행 단계 또는 공정을 나타낸다. 1~99 범위의 정수 값을 가지며, 낮은 숫자가 프로젝트 초기 단계를, 높은 숫자가 후기 단계를 의미한다.

Stage의 예시적 구성 (소프트웨어 개발):
- S1: 기획(Planning) - 요구사항 정의, 범위 설정
- S2: 설계(Design) - 아키텍처 설계, 상세 설계
- S3: 개발(Development) - 구현, 코딩
- S4: 테스트(Testing) - 단위 테스트, 통합 테스트
- S5: 배포(Deployment) - 스테이징, 프로덕션 배포
- S6: 운영(Operation) - 모니터링, 유지보수

Stage 값은 도메인에 따라 재정의할 수 있다. 예를 들어, 제조 도메인에서는 S1=설계, S2=조달, S3=조립, S4=검수, S5=인도로 정의할 수 있다.

2.2 Area 축 (22) - Y축
Area(Y축)는 프로젝트 내의 기능적 영역, 모듈, 부서, 또는 업무 도메인을 나타낸다. 2자리 대문자 알파벳 코드로 표현되며(예: FE=Frontend, BE=Backend), 시스템에서 관리하는 코드표에 의해 유효성이 검증된다. 이를 통해 프로젝트의 수평적 분할 구조를 명확히 표현한다.

Area의 예시적 코드:
- FE: Frontend - 사용자 인터페이스
- BE: Backend - 서버 로직
- DE: Design - UI/UX 디자인
- QA: Quality Assurance - 품질 보증
- INF: Infrastructure - 인프라, DevOps
- DA: Data/Analytics - 데이터 처리, 분석
- SE: Security - 보안
- DO: Documentation - 문서화

Area 코드표는 프로젝트 초기에 정의되며, 필요에 따라 확장할 수 있다. 최대 26×26=676개의 고유 Area를 정의할 수 있으나, 실무적으로는 10~30개 범위가 일반적이다.

2.3 Level 축 (23) - Z축
Level(Z축)은 작업 간 의존성과 수행 순서의 계층을 나타낸다. 1~99 범위의 정수 값을 가지며, 낮은 Level의 작업이 선행 작업, 높은 Level의 작업이 후행 작업이 된다. 동일한 Stage와 Area 내에서 Level 값이 낮은 작업이 먼저 완료되어야 높은 Level의 작업을 시작할 수 있다.

Level의 의미:
- Level 1: 해당 Stage와 Area에서 가장 먼저 수행되어야 하는 기초 작업
- Level 2: Level 1 작업에 의존하는 2차 작업
- Level 3: Level 2 작업에 의존하는 3차 작업
- 이하 동일

동일한 Stage와 Area 내에서의 선후 관계는 Level로 표현되며, 서로 다른 Area 간의 의존성은 별도의 속성으로 명시적으로 선언한다.

2.4 3차원 좌표 공간
이 3축이 정의하는 3차원 공간 상에 SAL 그리드(20)가 배치되며, 각 Task는 (Stage, Area, Level) 튜플로 고유하게 식별되는 좌표계의 특정 위치에 매핑된다. 이러한 3차원 구조는 프로젝트의 단계적 진행(Stage), 기능적 분할(Area), 의존 관계(Level)를 동시에 표현한다.

2.5 Stage × Area 매트릭스를 이용한 Task 선정
본 발명에서 SAL ID를 생성하기에 앞서, 프로젝트의 모든 작업은 Stage와 Area로 이루어진 2차원 매트릭스 상에서 선정된다. 이 매트릭스는 프로젝트의 어느 단계(Stage)에서 어떤 영역(Area)의 작업이 필요한지를 정의하는 기반이 되며, 선정된 각 Task에 Level 및 Variant를 부여하여 최종적으로 SAL ID가 생성된다.

2.5.1 매트릭스 기본 구조
Stage × Area 매트릭스는 X축(Stage)과 Y축(Area)으로 구성되는 2차원 평면이다. 각 Stage는 프로젝트의 시간적 진행 단계를 나타내고, 각 Area는 프로젝트의 기능적 영역을 나타낸다. 매트릭스의 각 셀은 특정 Stage와 특정 Area의 조합으로 정의되며, 해당 조합에 속하는 Task가 배치될 수 있는 위치가 된다.

2.5.2 Task 선정 프로세스
프로젝트 계획 단계에서 수행되는 Task 선정 프로세스는 다음과 같다:

첫째, 프로젝트의 Stage 범위를 결정한다. 프로젝트가 몇 개의 Stage로 구성되는지 정의하며, 예를 들어 소프트웨어 개발 프로젝트는 S1(개발 준비), S2(개발 1차), S3(개발 2차), S4(개발 3차), S5(개발 마무리)의 5개 Stage로 구성될 수 있다.

둘째, 프로젝트의 Area 범위를 결정한다. 프로젝트에서 관리할 기능 영역을 정의하며, 예를 들어 M(문서화), U(디자인), F(프론트엔드), BI(백엔드기반), BA(백엔드API), D(데이터베이스), S(보안), T(테스트), O(DevOps), E(외부연동), C(콘텐츠)의 11개 Area를 정의할 수 있다.

셋째, 각 Task에 대해 해당 Task가 속할 Stage와 Area를 결정함으로써 매트릭스 상의 위치를 선정한다. 동일한 Stage와 Area 조합에 복수의 Task가 배치될 경우 이들은 Level 값으로 구분된다.

넷째, Level 및 Variant를 부여한다. 각 Task에 Level(1~99)을 부여하여 동일한 Stage-Area 조합 내에서의 우선순위를 정의하고, 필요시 Variant(a~z)를 부여하여 병렬 작업을 구분한다.

다섯째, SAL ID를 생성한다. 선정된 Task의 Stage, Area, Level, Variant 정보를 인코딩하여 SAL ID를 생성한다.

2.5.3 실시예: SSAL Works 프로젝트의 5×11 매트릭스
실제 적용 사례로서 SSAL Works 프로젝트는 5×11 매트릭스를 사용하여 총 71개의 Task를 관리한다. 이 프로젝트는 5개의 Stage(S1부터 S5까지)와 11개의 Area(M, U, F, BI, BA, D, S, T, O, E, C)로 구성된다.

Stage별 Task 분포를 보면, S1(개발 준비)에는 9개의 Task가 배치되어 있으며, Vercel 배포 환경 설정, 도메인 연결, Sentry 에러 트래킹 등 인프라 구축 중심의 작업이 집중되어 있다. S2(개발 1차)에는 17개의 Task가 배치되어 있으며, Google OAuth 연동, 이메일 서비스, 핵심 API 구현 등 기본 기능이 구현된다. S3(개발 2차)에는 11개의 Task가 배치되어 있으며, AI 연동, 구독 권한 관리, AI 인터페이스 등 고급 기능이 구현된다. S4(개발 3차)에는 21개의 Task가 배치되어 있으며, 결제 시스템, 관리자 기능, 크레딧 관리, QA 테스트 등이 수행된다. S5(개발 마무리)에는 13개의 Task가 배치되어 있으며, 배포, 품질 보증, 안정화, 코드 최적화 등의 마무리 작업이 진행된다.

Area별 Task 분포를 보면, BA(백엔드API) 영역에 가장 많은 Task가 배치되어 있고, F(프론트엔드) 영역에도 다수의 Task가 분포한다. BI(백엔드기반), D(데이터베이스), S(보안), T(테스트) 영역에도 각 Stage에 걸쳐 고르게 Task가 배치되며, O(DevOps), M(문서화), U(디자인), E(외부연동), C(콘텐츠) 영역에도 필요에 따라 Task가 배치된다.

예를 들어, S1 Stage의 BI Area에는 Vercel 환경변수 설정, Supabase 클라이언트 초기화 등의 Task가 배치되어 있으며, S2 Stage의 BA Area에는 OAuth 콜백 API, 이메일 전송 API, 구독 취소 API 등 핵심 백엔드 API Task들이 배치되어 있다. 이처럼 동일한 Stage-Area 조합에 속하는 Task들은 Level 값으로 구분되며, Level이 낮은 Task가 선행 작업이 된다.

이러한 분포는 프로젝트 특성에 따라 결정되며, 초기 단계에서는 인프라 구축, 중기 단계에서는 핵심 기능 및 고급 기능 구현, 후기 단계에서는 결제 및 관리 기능과 품질 보증에 집중되는 전형적인 소프트웨어 개발 프로젝트의 패턴을 반영한다.

2.5.4 매트릭스와 SAL ID 생성의 관계
매트릭스에서 선정된 각 Task는 Stage 값과 Area 값을 가지며, 여기에 Level 및 Variant가 추가되어 3차원 좌표 (Stage, Area, Level)와 병렬 구분자 Variant가 결정된다. 이 정보가 인코딩되어 SAL ID가 생성되는 과정은 다음 섹션에서 상세히 설명한다.

3. SAL ID 구조
도 3은 프로젝트 Task를 식별하는 고유 체계인 SAL ID의 구조를 예시적으로 도시한다.

3.1 형식 정의
도 3을 참조하면, SAL ID는 `S{stage}{AREA}{level}{variant?}` 형식으로 정의된다.

각 구성요소의 상세 정의:
- 접두사 S: SAL ID 식별자 (고정)
- Stage(31): 1~2자리 정수 (1~99 범위, 예: 1, 99)
- Area(32): 2자리 영문 코드 (대문자 알파벳, 예: FE, BE)
- Level(33): 1~2자리 정수 (1~99 범위, 예: 1, 10)
- Variant(34): 병렬 분기 구분을 위한 선택적 문자 (소문자 a~z, 예: a, b)

3.2 SAL ID 예시
다음은 유효한 SAL ID의 예시와 그 의미이다:

- **S1FE1**: Stage 1, Frontend, Level 1의 단일 작업을 의미한다. (Variant 없음)
- **S1FE1a**: Stage 1, Frontend, Level 1의 위치에서 첫 번째 병렬 분기('a') 작업을 의미한다.
- **S1FE1b**: Stage 1, Frontend, Level 1의 위치에서 두 번째 병렬 분기('b') 작업을 의미한다.
- **S2BE2**: Stage 2, Backend, Level 2의 작업을 의미한다.
- **S3QA1**: Stage 3, QA, Level 1의 작업을 의미한다.
- **S10DA5c**: Stage 10, Data, Level 5의 위치에서 세 번째 병렬 분기('c') 작업을 의미한다.

3.3 Variant의 용도
Variant는 동일한 (Stage, Area, Level) 좌표에 여러 개의 병렬 작업이 존재할 때 이들을 구별하기 위해 사용된다. 예를 들어, S2FE2a는 Stage 2, Frontend(FE) 영역, Level 2 위치의 'a' 작업에 해당한다. 동일 좌표에서 병렬로 수행 가능한 복수의 작업이 있을 경우 a, b, c 등으로 구분한다.

3.4 실시예: SSAL Works 프로젝트의 실제 SAL ID
SSAL Works 프로젝트에서 실제로 사용되는 SAL ID의 예시는 다음과 같다:

S1BI1은 Stage 1(개발 준비), BI(백엔드 기반) 영역, Level 1에 해당하며, 환경변수 설정 작업을 나타낸다. 이 작업은 Vercel 배포 환경에 필요한 SUPABASE_URL, SUPABASE_ANON_KEY 등의 환경변수를 설정하고, .env.example 파일을 생성하며, 민감 정보를 Git에서 제외하는 작업으로 구성된다.

S2BA5는 Stage 2(개발 1차), BA(백엔드 API) 영역, Level 5에 해당하며, 프로젝트 관리 API 작업을 나타낸다. 이 작업은 프로젝트 생성, 목록 조회, 수정, 완료 처리 등의 CRUD API를 구현하며, S1D1(데이터베이스 스키마)에 의존한다.

S3E1은 Stage 3(개발 2차), E(외부 연동) 영역, Level 1에 해당하며, AI 서비스 연동 작업을 나타낸다. 이 작업은 Gemini, ChatGPT, Perplexity 등 외부 AI 서비스와의 연동 API를 구현한다.

S5U1과 S5U2는 Stage 5(개발 마무리), U(디자인) 영역에 해당하며, 각각 Level 1과 Level 2의 디자인 품질 보증 작업을 나타낸다. 이처럼 동일한 Stage-Area 조합에 복수의 Task가 배치될 경우 Level 값으로 구분되며, Level이 낮은 작업이 선행된다.

이러한 SAL ID들은 각각 고유한 3차원 좌표를 가지며, Stage 값(1~5), Area 코드(M, U, F, BI, BA, D, S, T, O, E, C), Level 값(1~9)의 조합으로 프로젝트 전체의 71개 Task를 체계적으로 식별한다.

3.5 식별자의 특징
이 식별자는 텍스트 형식이므로 별도의 변환 없이 직접 읽고 이해할 수 있으며, 정규식 기반 파싱을 통해 자동화된 처리가 가능하다.

4. 파서 모듈
도 4는 입력된 SAL ID를 처리하는 파서 모듈의 흐름도를 도시한다.
파서 모듈(40)은 입력된 SAL ID(예: `S2FE2a`)를 해석하여 프로세스가 이해하고 실행 가능한 정규화된 좌표 객체로 변환하는 핵심 엔진이다. 이 과정은 크게 4단계로 진행된다.

4.1 입력
ID 생성 모듈(30)로부터 `S2FE2a`와 같은 원시 문자열을 입력받는다. 이 문자열에는 Stage, Area, Level, Variant 정보가 압축되어 있다.

4.2 파싱 알고리즘 상세
파싱 프로세스는 다음의 순차적인 검증 단계를 거친다.

1) 정규식 매칭 (Lexical Analysis):
입력된 ID가 프로세스의 정의된 형식과 일치하는지 검증한다. 사용되는 정규 표현식은 `^S(\d{1,2})([A-Z]{2})(\d{1,2})([a-z])?$`이다. 이 표현식은 다음과 같이 분해된다:
- `^S`: 'S' 문자로 시작 (SAL ID 접두사)
- `(\d{1,2})`: 1~2자리 정수 캡처 (Stage 값)
- `([A-Z]{2})`: 대문자 알파벳 2자리 캡처 (Area 코드)
- `(\d{1,2})`: 1~2자리 정수 캡처 (Level 값)
- `([a-z])?`: 소문자 알파벳 1자리 선택적 캡처 (Variant)
- `$`: 문자열 끝
형식에 맞지 않으면 즉시 예외 처리 단계로 분기한다.

2) 범위 검사 (Range Validation):
추출된 숫자(Stage, Level)가 유효 범위(1~99) 내에 있는지 확인한다. 범위를 벗어난 값(예: Stage=0, Level=100)은 오류로 처리된다.

3) 코드 유효성 검사 (Semantic Validation):
중간의 영문 코드(Area Code)가 `Area_Code_Master`(영역 코드 마스터 테이블)에 등록된 유효한 영역 코드인지 확인한다. 이 마스터 테이블은 프로젝트 초기에 정의되며, 예를 들어 FE(Frontend), BE(Backend), QA(Quality Assurance) 등이 포함된다. 등록되지 않은 코드는 실행할 수 없는 작업으로 간주한다.

4) 고유성 검사 (Uniqueness Check):
(Stage, Area, Level, Variant) 조합이 기존에 등록된 SAL ID와 중복되지 않는지 확인한다. 중복 시 신규 등록이 거부된다.

5) 정렬 키 생성 (Sort Key Generation):
유효성이 확인되면, 데이터베이스 정렬이나 실행 순서 보장을 위해 고유한 정렬 키를 생성한다. 정렬 키 생성 공식은 다음과 같다:
- Stage를 2자리 문자열로 패딩 (예: 2 → "02")
- Area 코드를 그대로 사용 (예: "FE")
- Level을 2자리 문자열로 패딩 (예: 2 → "02")
- Variant가 있으면 그대로 추가, 없으면 빈 문자열
- 최종 키: `{Stage_Padded}_{Area}_{Level_Padded}_{Variant}` (예: "02_FE_02_a")

4.3 파싱된 객체 구조 (Parsed Object Schema)
파싱이 성공하면 다음 필드를 포함하는 정규화된 객체가 생성된다:
- `raw_id`: 원본 문자열 (String, 예: "S2FE2a")
- `stage`: 추출된 Stage 값 (Integer, 예: 2)
- `area`: 추출된 Area 코드 (String, 예: "FE")
- `level`: 추출된 Level 값 (Integer, 예: 2)
- `variant`: 추출된 Variant (String 또는 null, 예: "a")
- `sort_key`: 생성된 정렬 키 (String, 예: "02_FE_02_a")
- `parsed_at`: 파싱 시점 타임스탬프 (ISO 8601 형식)

4.4 예외 처리 (Exception Handling)
이 검증 과정 중 어느 하나라도 실패하거나, 매핑되지 않는 ID의 경우 Unassigned Queue(46)로 이동된다. 이는 프로세스를 중단시키지 않고, 해당 작업을 '대기열'에 넣어 관리자가 수동으로 재정의하거나 해결할 수 있도록 하는 안전장치이다. Unassigned Queue에 기록되는 정보는 다음을 포함한다:
- 실패한 원본 ID
- 실패 사유 (정규식 불일치, 범위 초과, 미등록 코드, 중복 등)
- 실패 시점 타임스탬프
- 입력 출처 (수동 입력 또는 자동 생성)

4.5 출력 및 후속 연계
모든 검증을 통과하면 파싱된 객체(Parsed Object)가 생성된다. 이 객체는 다음 단계인 SAL 그리드 생성기(52)에 전달되어, 개별 Task 지시서 및 검증 지시서를 생성하는 기초 데이터로 사용된다.

요약하자면, 파서 프로세스는 불완전한 문자열을 실행 가능한 정규화된 좌표 객체로 변환하고 오류는 별도로 격리하여 시스템 흐름에 영향을 주지 않는 과정이다.

5. 그리드 생성 프로세스
도 5는 그리드를 생성하는 순차적 프로세스를 도시한다.

5.1 기본 정보 입력 (51)
프로젝트 실행에 필요한 핵심 정보인 Stage, Area, Level, Task Name, SAL ID가 입력된다.

5.2 SAL 그리드 생성기 및 지시서 생성 (52)
SAL 그리드 생성기(52)는 입력된 정보를 바탕으로 Task 지시서 및 검증 지시서를 자동 생성한다.

5.2.1 Task 지시서 구조
Task 지시서는 작업 시행에 필요한 기본 정보를 구조화하여 제공한다. Task 지시서는 Task ID, Task Name, Task Goal, Prerequisites, Specific Instructions, Expected Output Files, Completion Criteria, Tech Stack, Agents, Tools, Execution Type 등의 필드를 포함한다.

5.2.2 실시예: SSAL Works 프로젝트의 Task 지시서
SSAL Works 프로젝트의 S2BA5 Task는 "프로젝트 관리 API" 작업으로, 사용자 프로젝트 생성, 목록 조회, 수정, 완료 처리를 위한 Serverless API 구현을 목표로 한다. 이 Task의 지시서는 다음과 같이 구성된다.

Task ID는 S2BA5이며, Task Name은 "프로젝트 관리 API"이다. Task Goal은 사용자 프로젝트 생성, 목록 조회, 수정, 완료 처리를 위한 Serverless API 구현이다. Prerequisites로는 S1D1(DB 스키마 확정)이 완료되어야 한다.

Specific Instructions는 4개의 API 엔드포인트 구현을 포함한다. 첫째, api/projects/create.js에서 POST /api/projects 엔드포인트로 프로젝트 생성을 처리한다. 둘째, api/projects/list.js에서 GET /api/projects 엔드포인트로 프로젝트 목록 조회를 처리하며, 페이지네이션과 상태 필터를 지원한다. 셋째, api/projects/update.js에서 PATCH /api/projects/[id] 엔드포인트로 프로젝트 정보 수정을 처리한다. 넷째, api/projects/complete.js에서 POST /api/projects/[id]/complete 엔드포인트로 프로젝트 완료 처리를 한다.

Expected Output Files는 api/projects/create.js, api/projects/list.js, api/projects/update.js, api/projects/complete.js 4개 파일이다.

Completion Criteria는 6개 조건을 포함한다. POST /api/projects로 프로젝트를 생성할 수 있어야 하고, GET /api/projects로 목록 조회가 가능하며 페이지네이션과 상태 필터가 작동해야 한다. PATCH /api/projects/[id]로 프로젝트 수정이 가능해야 하고, POST /api/projects/[id]/complete로 프로젝트 완료 처리가 되어야 한다. 모든 API는 인증 필수이며, RLS 정책이 적용되어야 한다. 응답 형식은 JSON이고, 에러 처리가 구현되어 있어야 한다.

Tech Stack은 Vercel Serverless Functions, Supabase Database, JavaScript를 사용한다. Task Agent는 backend-developer이며, Tools는 supabase-js를 사용한다. Execution Type은 AI-Only이다.

5.2.3 검증 지시서 구조
검증 지시서는 작업 결과물의 품질을 확인하기 위한 기준과 절차를 구조화하여 제공한다. 검증 지시서는 Verification Criteria, Test Commands, Build Verification, Integration Verification 등의 필드를 포함한다.

5.2.4 실시예: SSAL Works 프로젝트의 검증 지시서
S2BA5 Task의 검증 지시서는 다음과 같이 구성된다.

Verification Criteria는 5개 그룹으로 구성된다. 첫째, API 엔드포인트 확인으로 POST /api/projects, GET /api/projects, PATCH /api/projects/[id], POST /api/projects/[id]/complete가 존재하는지 확인한다. 둘째, 인증 및 권한 확인으로 모든 엔드포인트에 인증이 필요하고 본인 프로젝트만 수정 및 삭제 가능한지 확인한다. 셋째, 응답 형식 확인으로 성공 시 JSON 형식 응답, 실패 시 에러 메시지와 HTTP 상태 코드가 적절한지 확인한다. 넷째, DB 연동 확인으로 projects 테이블 CRUD 작동 여부를 확인한다. 다섯째, 에러 처리 확인으로 잘못된 요청, 권한 없는 접근, DB 오류 처리가 되는지 확인한다.

Test Commands로는 실제 API 호출 예시를 제공한다. 프로젝트 생성은 curl -X POST http://localhost:3000/api/projects -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"name":"Test Project"}' 명령으로 테스트한다. 프로젝트 목록 조회는 curl -X GET http://localhost:3000/api/projects?page=1&limit=10&status=active -H "Authorization: Bearer $TOKEN" 명령으로 테스트한다.

Build Verification은 vercel build 명령으로 빌드 성공 여부를 확인하고, API 파일이 .vercel/output/functions/ 디렉토리에 생성되는지 확인한다.

Integration Verification은 2개 항목을 포함한다. 첫째, S1D1의 DB 스키마 projects 테이블과 연동되는지 확인한다. 둘째, S2S1의 인증 미들웨어가 적용되는지 확인한다.

5.2.5 점진적 의존성 갱신
특정 SAL ID의 변경이 필요한 경우, 시스템은 변경된 SAL ID를 dependency 필드에서 참조하는 Task들을 추출하여 이들의 의존성 정보를 갱신한다.

5.3 시퀀서: SAL ID 조정 (53)
시퀀서(53)는 Task 간의 실행 순서를 분석하여 Level 충돌을 감지하고 SAL ID를 자동으로 조정하는 모듈이다.

시퀀서는 다음의 순차적 절차를 수행한다. 첫째, 전체 Task 지시서들의 dependencies 필드를 파싱하여 각 Task에 대한 선행 Task 목록과 후행 Task 목록을 모두 추출한다. 선행 Task는 해당 Task의 dependencies 필드에 명시된 Task이며, 후행 Task는 dependencies 필드에 해당 Task를 참조하고 있는 Task이다. 둘째, 각 Task에 대해 선행-후행 의존성 관계를 분석하고, Level 값의 크고 작음이 의존성 관계와 일치하는지 검사한다. 후행 Task의 Level 값이 선행 Task의 Level 값보다 작은 경우, 의존성 관계와 Level 순서가 불일치하므로 이를 Level 충돌로 판정한다. 셋째, 충돌이 감지된 경우 의존성 관계에 따라 후행 Task의 Level 값을 선행 Task의 Level 값보다 큰 값으로 자동 증가시켜 SAL ID를 조정한다. 예를 들어 S2F3이 S2F5에 의존하는 경우, 의존성 관계는 S2F5가 선행이고 S2F3이 후행이나, Level 값은 3 < 5로 S2F3이 먼저 실행되므로 불일치가 발생하며, 의존성 관계에 따라 S2F3을 S2F6으로 조정한다.

5.4 배분기: 자원 배분 (54)
배분기(54)는 Task 지시서를 분석하여 작업 수행에 필요한 에이전트와 도구를 자동으로 식별하고 배정하는 모듈이다.

배분기는 다음의 배정 절차를 수행한다. 첫째, Task 지시서의 Area 코드를 확인하여 Area별 에이전트 매핑 테이블을 조회한다. 예를 들어 Area가 F(Frontend)이면 frontend-developer를, BA(Backend APIs)이면 backend-developer를, S(Security)이면 security-specialist를 후보로 선정한다. 둘째, Task 지시서의 execution_type 필드를 확인한다. execution_type이 AI-Only인 경우 AI 에이전트만 배정하고, Human-AI인 경우 사람과 AI 에이전트를 모두 배정하며, Manual인 경우 사람만 배정한다. 셋째, Task 수행을 담당하는 Task 에이전트와 결과를 검증하는 검증 에이전트를 분리하여 배정한다. 동일한 에이전트가 작성과 검증을 동시에 담당하지 않도록 한다. 예를 들어 Task 에이전트가 backend-developer인 경우, 검증 에이전트는 code-reviewer 또는 qa-specialist로 배정한다. 넷째, Task 지시서의 tools 필드에 명시된 도구 목록을 확인하여 에이전트에게 제공할 도구를 배정한다.

5.5 SAL 그리드 완성 (55)
모든 과정이 완료되면 SAL 그리드 객체가 최종 완성된다. 이 그리드는 실시예에 따라 22개 내외의 속성으로 구성될 수 있다.

5.6 SAL Grid 22개 속성 상세
본 발명의 일 실시예에서, SAL Grid는 다음 6개 그룹의 22개 속성을 포함할 수 있다. 이는 예시적 구성이며, 도메인에 따라 가감될 수 있다.

(1) 기본 정보
1. Stage: 프로젝트의 진행 단계 (Integer, 예: 1)
2. Area: 기능적 영역 코드 (String, 예: "FE")
3. Task ID: SAL ID와 동일한 식별자 (String, 예: "S1FE1a")
4. Task Name: 인간 가독형 작업명 (String, 예: "Login UI Dev")

(2) 작업 지시
5. Task 지시서: 구체적인 Task 지시 사항 (String/Data)
6. Task Agent: 작업을 수행할 주체 (String, 예: "Claude 3.5")
7. Tools: 작업에 필요한 도구 목록 (List, 예: ["VS Code", "React"])
8. Execution Type: 실행 방식 (String, 예: "Manual", "Auto")
9. Dependencies: 선행 작업 ID 목록 (List<String>)

(3) 작업 실행
10. Task Progress: 진행률 (Percentage, 0~100)
11. Task Status: 현재 상태 (Enum: Pending, Running, Done, Failed)
12. Generated Files: 산출물 파일 경로 목록 (List<Path>)
13. SAL ID History: 변경 이력 로그 (List<Log>)

(4) 검증 지시
14. Verification Instruction: 검증 기준 및 절차 (String)
15. Verification Agent: 검증을 수행할 주체 (String, 예: "TestRunner")

(5) 검증 실행
16. Test: 단위 테스트 실행 결과 (Boolean/String)
17. Build: 빌드 성공 여부 (Boolean)
18. Integration Verification: 통합 테스트 결과 (Boolean)
19. Blockers: 진행을 막는 방해 요소 (String)

(6) 검증 완료
20. Comprehensive Verification: 종합 검증 결과 (Boolean)
21. Verification Status: 검증 상태 (Enum: Unverified, Verified)
22. Remarks: 특이사항 및 비고 (String)

6. SAL 그리드 기록 및 뷰어 시스템
도 6은 본 발명의 실시예에 따른 SAL 그리드 기록기(60)가 데이터를 시각화하는 뷰어 프로세스의 계층적 아키텍처를 도시한다.
이 프로세스는 시스템의 견고성을 보장하기 위해 다음 3계층(3-Layer) 구조로 설계되었다.

6.1 SAL 그리드 레코더 (60)
SAL 그리드 레코더(60)는 Task 실행 및 검증 수행 결과를 실시간으로 기록하는 핵심 모듈이다. 기록되는 데이터는 다음의 구조를 따른다:

6.1.1 레코더 로그 데이터 구조
각 Task에 대해 기록되는 로그 데이터는 다음 필드를 포함한다:
- sal_id: 해당 Task의 SAL ID (문자열, 예: "S2FE2a")
- timestamp: 이벤트 발생 시각 (ISO 8601 형식, 예: "2026-01-13T15:30:00Z")
- event_type: 이벤트 유형 (열거형: TASK_STARTED, TASK_COMPLETED, VERIFICATION_PASSED, VERIFICATION_FAILED, BLOCKER_DETECTED)
- duration_seconds: 작업 소요 시간 (정수, 초 단위)
- artifacts: 생성된 산출물 파일 경로 목록 (문자열 리스트)
- test_result: 테스트 통과 여부 (불린값)
- build_result: 빌드 성공 여부 (불린값)
- agent_id: 작업을 수행한 에이전트 식별자 (문자열)
- remarks: 특이사항 또는 오류 메시지 (문자열)

6.1.2 원자적 쓰기 (Atomic Write)
레코더는 기록 시 원자적 쓰기(Atomic Write)를 수행한다. 쓰기 도중 중단되더라도 부분 기록이 발생하지 않도록 트랜잭션 방식으로 처리된다.

6.1.3 실시예: SSAL Works 프로젝트의 SAL 그리드 기록 데이터
SSAL Works 프로젝트의 S1BI1 Task에 대해 SAL 그리드 레코더(60)가 기록한 실제 데이터는 다음과 같다.

기본 식별 정보로서 task_id는 S1BI1이고, task_name은 "환경변수 설정"이며, stage는 1, area는 BI이다.

Task 실행 정보로서 task_status는 Completed, task_progress는 100이며, generated_files는 ".env.example, S1_개발준비/BI_Backend_Infrastructure/S1BI1_환경변수_목록.md"이다. task_agent는 devops-troubleshooter이고, execution_type은 Human-AI이며, dependencies는 S1F1이다.

검증 정보로서 verification_status는 Verified이고, verification_agent는 devops-troubleshooter이다. test 필드는 {"env_example":"✅ 파일 생성됨 (13개 변수)","documentation":"✅ ENV_SETUP.md 완성 (213줄)","gitignore":"✅ 환경변수 파일 제외됨"}이고, build 필드는 {"status":"N/A (설정/문서)"}이다. integration_verification 필드는 {"client_side":"✅ anon key 사용 (정상)","server_side":"✅ service role key 문서화","vercel_setup":"✅ 가이드 포함"}이다. blockers 필드는 {"status":"No Blockers ✅","fixed_issues":[".env.example 생성"]}이고, comprehensive_verification 필드는 "[task_instruction] ✅ 충족, [test] ✅ 통과, [build] ✅ 통과, [final] ✅ Passed"이다.

비고 정보로서 remarks는 "SUPABASE_URL, SUPABASE_ANON_KEY 등 설정, 민감 정보 Git 제외"이고, modification_history는 "[v1.0.0] .env 구조 설계, Vercel 환경변수 설정 완료"이다.

이와 같이 SAL 그리드 레코더(60)는 Task의 실행 및 검증과 관련된 모든 정보를 구조화된 형태로 기록한다.

6.2 데이터베이스 시스템(61)
이 계층은 기록기 및 뷰어가 참조할 원천 데이터를 정의한다. 시스템의 구축 환경이나 보안 요구사항에 따라 대표적으로 데이터베이스(관계형 DB)와 파일 시스템(JSON/XML)을 지원하는 어댑터 인터페이스를 제공한다.
이를 통해, 중앙 집중식 관리가 필요한 기업 환경(DB)과 분산 버전 관리가 필요한 오픈소스 환경(File/Git)을 모두 지원할 수 있다.

6.3 뷰어 엔진 (62)
뷰어 엔진(62)은 저장된 데이터를 시각화 가능한 형태로 변환하는 중간 계층이다.

6.3.1 Data Loader
Data Loader는 선택된 데이터베이스로부터 원시 데이터를 비동기적으로 로드한다. 비동기 처리를 통해 대용량 프로젝트에서도 UI가 차단되지 않고 응답성을 유지한다. 로드된 데이터는 State Parser에 전달된다.

6.3.2 State Parser
State Parser는 로드된 데이터에서 Task의 상태(Status), 진행률(Progress), 검증 결과(Verification Result)를 파싱하여 시각화 가능한 객체 모델로 변환한다. 변환된 객체는 다음 정보를 포함한다:
- 3차원 좌표 (Stage, Area Index, Level)
- 현재 상태 (Pending, Running, Done, Failed)
- 진행률 (0~100%)
- 시각적 속성 (색상, 크기, 애니메이션 여부)

6.4 UI 렌더링 시스템(63)
UI 렌더링 시스템(63)은 SAL 그리드 뷰어의 핵심 기능을 수행하며, 2차원 카드 뷰와 3차원 블록 뷰를 제공한다.

6.4.1 2차원 카드 뷰
2차원 카드 뷰는 Stage별, Area별로 그룹화된 Task 카드 목록을 표시한다. 각 카드는 Task ID, Task 명칭, 상태(task_status), 진행률(task_progress), 검증 상태(verification_status) 등 SAL 그리드의 주요 속성을 표시하며, 반응형 그리드 레이아웃으로 배치된다. 사용자는 카드를 클릭하여 Task의 상세 정보를 확인할 수 있다.

6.4.2 3차원 블록 뷰
3차원 블록 뷰는 State Parser로부터 변환된 데이터를 3차원 그래픽 라이브러리를 사용하여 블록 형태로 렌더링한다. 각 Task는 다음 공식에 따라 3차원 공간에 배치된다:
- X 좌표 = Stage × Grid_Unit_Width
- Y 좌표 = Area_Index × Grid_Unit_Depth
- Z 좌표 = Level × Grid_Unit_Height

여기서 Grid_Unit은 시각화 단위 크기이며, Area_Index는 Area 코드의 순서에 따른 인덱스 값이다.

6.4.3 상태별 시각화 표현
각 Task의 상태에 따라 다음과 같이 시각적으로 구분하여 표현한다:
- Pending (대기 중): 회색
- In Progress (실행 중): 노란색
- Executed (실행 완료): 파란색
- Completed (검증 완료): 녹색
- Failed (실패): 빨간색

6.4.4 Dashboard
Dashboard는 프로젝트의 전체 현황을 집계하여 표시한다. 전체 Task 수, 상태별 Task 수(Pending, In Progress, Executed, Completed 등), Stage별 완료율을 표시한다.

7. SAL ID 체인 관리 모듈
도 7은 SAL ID 체인 모듈(70)의 시스템 구조 및 관리 방식을 도시한다.

Task의 SAL ID는 변경될 수 있다. SAL ID가 변경된다는 것은 Stage, Area, Level 중 하나 이상이 변경되어 해당 Task가 3차원 SAL 그리드 상에서 다른 좌표를 갖게 되었음을 의미한다. SAL ID 체인 모듈은 이러한 SAL ID 변경 이력을 관리한다.

7.1 SAL ID 체인 목록 (71)
Task의 SAL ID가 변경될 때마다 변경 이력을 체인 형태로 기록한다. 도 7의 예시에서 S1A1 → S2A1 → S2B2와 같이 기록된다. 체인의 마지막 세그먼트가 해당 Task의 최신 SAL ID(72)이다.

7.1.1 실시예: SSAL Works 프로젝트의 SAL ID 변경 이력
SSAL Works 프로젝트에서는 프로젝트 진행 중 2건의 SAL ID 변경이 발생했다.

첫째, Sentry 모니터링 설정 Task는 초기에 S4BI1로 계획되었다. 이는 Stage 4(개발 3차)의 BI(백엔드 기반) 영역에서 모니터링을 설정하려는 계획이었다. 그러나 프로젝트 진행 중 오류 추적 시스템은 개발 초기부터 설정되어야 모든 Stage에서 발생하는 오류를 효과적으로 추적할 수 있다고 판단되었다. 따라서 이 Task는 S1BI2로 변경되어 Stage 1(개발 준비) 단계로 이동했다. SAL ID 체인은 S4BI1 → S1BI2로 기록된다.

둘째, AI Q&A UI Task는 초기에 S4F2로 계획되었다. 이는 Stage 4(개발 3차)의 F(프론트엔드) 영역에서 AI 질의응답 UI를 개발하려는 계획이었다. 그러나 AI 연동 작업이 Stage 3(개발 2차)에 집중되어 있어, AI Q&A UI도 같은 Stage에서 함께 개발하는 것이 효율적이라고 판단되었다. 따라서 이 Task는 S3F1로 변경되어 Stage 3으로 이동했다. SAL ID 체인은 S4F2 → S3F1로 기록된다.

이러한 변경 이력은 SAL ID 체인 목록(71)에 기록되며, 각 체인의 마지막 세그먼트(S1BI2, S3F1)가 해당 Task의 최신 SAL ID(72)로 관리된다.

7.2 체인 덧붙이기 (73)
SAL ID가 변경될 때 기존 ID를 삭제하지 않고 새로운 ID를 체인에 덧붙인다(Append). 도면에 표시된 바와 같이 Append-Only 방식으로 동작한다.

앞서 실시예에서 Sentry 모니터링 Task가 S4BI1에서 S1BI2로 변경될 때, 시스템은 기존의 S4BI1 ID를 삭제하지 않는다. 대신 체인에 S1BI2를 덧붙여 S4BI1 → S1BI2 형태로 기록한다. 이는 변경 이력의 추적성을 보장하고, 이전 ID로 참조하던 외부 시스템이나 문서가 깨지지 않도록 한다.

7.3 리졸버(74) 및 자가 치유(Self-Healing)
리졸버(74)는 외부 시스템이나 사용자가 구(Old) SAL ID로 작업을 조회할 때, SAL ID 체인 목록을 순회하여 현재 활성 상태인 최신 SAL ID(72)를 반환하는 라우팅 기능을 수행한다. 이를 통해 SAL ID가 변경되더라도, 기존 참조(Reference)가 깨지지 않고 자동으로 최신 ID로 연결되는 '참조 무결성(Referential Integrity)'과 '자가 치유(Self-Healing)' 메커니즘을 제공한다.

실시예에서 사용자가 S4BI1로 Task를 조회하면, 리졸버(74)는 SAL ID 체인 목록(71)을 확인하여 S4BI1 → S1BI2 체인을 발견한다. 그리고 체인의 마지막 세그먼트인 S1BI2를 최신 SAL ID(72)로 반환한다. 사용자는 자동으로 S1BI2 Task의 정보를 받게 되며, SAL ID가 변경되었다는 사실을 인지하지 못한 채 정상적으로 작업을 조회할 수 있다.

8. 멀티태스크 오케스트레이션 시스템
도 8은 본 시스템의 전체적인 운영 주기를 9단계로 도시하며, 이는 청구항 1의 (a)~(f) 6단계를 실행 프로세스 관점에서 세부 확장한 것이다. 각 단계는 다음과 같은 상세 프로세스를 수행한다.

8.1 계획 수립 (81)
Stage × Area 매트릭스 상에서 프로젝트에 필요한 Task를 선정하고, 각 Task에 Level 및 Variant를 부여한다.

8.2 SAL ID 생성 (82)
선정된 Task의 Stage, Area, Level, Variant 정보를 인코딩하여 고유한 SAL ID를 생성한다.

8.3 SAL 그리드 구축 (83)
생성된 SAL ID를 파서(40)가 파싱하여 3차원 좌표를 추출하고, SAL 그리드 생성기(52)가 Task 지시서 및 검증 지시서를 생성하며, 시퀀서(53)가 SAL ID를 조정하고, 배분기(54)가 에이전트와 도구를 배정하여 복수의 속성으로 구성된 프로젝트 SAL 그리드를 구축한다.

8.4 Task 실행 (84)
할당된 에이전트가 각 Task 지시서에 따라 개별 작업을 수행한다. 실행 중 발생하는 상태 변화(Status), 진행률(Progress), 생성된 파일(Artifacts), 소요 시간(Duration) 등의 동적 속성(Dynamic Properties)은 실시간으로 추적된다.

8.5 검증 수행 (85)
작업이 완료되면 검증 에이전트(Verification Agent)가 투입되어 테스트 결과(`test_result`), 빌드 성공 여부(`build_result`), 코드 품질 등을 검증한다.

8.6 실행 및 검증 결과 기록 (86)
수행 및 검증 결과는 SAL 그리드 기록기를 통해 실시간으로 기록된다.

8.7 Stage 검증 (87)
해당 Stage 전체의 완료 여부를 검증한다. Stage 내 모든 Task 완료 여부, 빌드 및 테스트 통과 여부, 의존성 체인 완결성, 산출물 생성 여부, 차단 요소(Blockers) 존재 여부를 확인한다.

8.7.1 실시예: SSAL Works 프로젝트의 Stage 1 검증
SSAL Works 프로젝트의 Stage 1(개발 준비) 검증에서는 다음 항목을 확인한다.

첫째, Task 완료 상태를 확인한다. Stage 1은 총 8개의 Task로 구성되어 있으며, S1M1(개발 가이드), S1F1(Vercel 프로젝트 설정), S1F2(vercel.json 설정), S1BI1(환경변수 설정), S1D1(DB 스키마 확정), S1S1(Supabase Auth Provider 설정), S1T1(테스트 환경 설정), S1O1(DNS 설정)이 모두 Completed 상태이며 Verification Status가 Verified임을 확인한다. 완료율은 8/8로 100%이다.

둘째, 빌드 검증을 수행한다. Vercel Build 도구로 빌드를 실행하여 성공 여부를 확인하고, vercel.json 설정이 완료되었는지, 환경변수 설정 가이드가 완료되었는지 확인한다. 빌드 오류와 경고가 0개임을 확인한다.

셋째, 의존성 체인 검증을 수행한다. Stage 내 Task 간 의존성 구조를 확인한다. S1F2는 S1F1에 의존하고, S1BI1은 S1F1에 의존하며, S1S1은 S1BI1에 의존하고, S1T1은 S1F1에 의존한다. 순환 의존성이 없으며, 미해결 의존성이 없음을 확인한다. 또한 다음 Stage인 S2의 의존성 준비 상태를 확인한다. S2M1은 S1M1에 의존하고, S2F1은 S1F2에 의존하며, S2F2는 S1F1에 의존하는 등 총 7개의 의존성이 모두 준비 완료 상태임을 확인한다.

넷째, 산출물 검증을 수행한다. 총 54개 이상의 파일이 생성되었는지 확인한다. Documentation 영역에서 1개, Frontend 영역에서 2개, Backend_Infra 영역에서 1개, Database 영역에서 42개 이상, Security 영역에서 1개, Testing 영역에서 5개 이상, DevOps 영역에서 1개의 산출물이 생성되었음을 확인한다.

다섯째, 차단 요소 확인을 수행한다. 의존성 차단 요소, 환경 설정 차단 요소, 외부 API 차단 요소, 리소스 차단 요소가 없음을 확인한다.

8.8 리포트 생성 (88)
SAL 그리드 레코더(86)가 기록한 Task 실행 결과 및 검증 결과를 참고하여, Stage 내 모든 Task 완료 여부, 빌드 및 테스트 통과 여부, 의존성 체인 완결성, 차단 요소(Blockers)를 확인하고 검증 리포트를 생성한다.

8.8.1 실시예: SSAL Works 프로젝트의 Stage 1 검증 리포트
SSAL Works 프로젝트의 Stage 1 검증 리포트는 다음과 같이 구성된다.

리포트는 Stage 정보, 검증자, 검증일을 포함하는 헤더로 시작한다. Stage 1은 개발 준비 단계이며, Main Agent가 2025년 12월 13일에 검증을 수행했다.

첫 번째 섹션은 Stage 완료 현황이다. 8개 Task의 Task ID, Task Name, Task Status, Verification Status를 정리하고, 완료율 8/8(100%)을 기록한다. 미완료 Task가 없음을 명시한다.

두 번째 섹션은 빌드 검증이다. Vercel Build 성공 여부, vercel.json 설정 완료 여부, 환경변수 설정 가이드 완료 여부를 기록하고, 오류 0개, 경고 0개를 명시한다. ESLint 설정 완료 여부도 함께 기록한다.

세 번째 섹션은 테스트 검증이다. Jest 설정 완료 여부와 설정 파일 경로, 테스트 예시 파일 경로를 기록한다. Playwright 설정 완료 여부와 설정 파일 경로, E2E 테스트 예시 파일 경로를 기록한다. Stage 1은 개발 준비 단계로 테스트 환경 설정만 완료하고 실제 기능 테스트는 Stage 2부터 진행된다는 점을 명시한다.

네 번째 섹션은 의존성 체인 검증이다. Stage 내 Task 간 의존성 구조를 정리하고, 순환 의존성과 미해결 의존성이 없음을 명시한다. 다음 Stage인 S2의 의존성 준비 상태를 확인하여 7개 의존성이 모두 준비 완료되었음을 기록한다.

다섯 번째 섹션은 산출물 검증이다. Area별 산출물 상태를 정리하고, 총 54개 이상의 파일이 생성되었음을 명시한다. 각 파일의 경로를 나열한다.

여섯 번째 섹션은 차단 요소 확인이다. 의존성 차단 요소, 환경 설정 차단 요소, 외부 API 차단 요소, 리소스 차단 요소가 모두 없음을 기록한다.

일곱 번째 섹션은 종합 판정이다. 12개 항목의 체크리스트를 작성하고 모든 항목이 완료되었음을 확인한다. 최종 판정으로 Stage 1 Gate AI 검증 통과를 선언하고, 8/8 Task 완료 및 검증됨, 54개 이상 산출물 생성 완료, 다음 Stage 진행 가능, Project Owner 최종 승인 대기 상태임을 명시한다.

여덟 번째 섹션은 다음 Stage 준비 상태이다. S2(개발 1차)에서 필요한 7개 항목이 모두 준비 완료되었음을 기록하고, S2에서 수행할 12개 Task의 목록과 주요 작업 내용을 명시한다.

8.9 Stage 승인 (89) (Stage Gate)
생성된 리포트를 기반으로 다음 단계(Next Stage)로의 진입 여부를 최종 승인한다. 만약 승인이 거절(반려)될 경우, 프로세스는 Task 실행(84) 단계로 회귀(Loopback)하여 수정된 프로세스를 재실행한다.

8.9.1 실시예: SSAL Works 프로젝트의 Stage 1 승인
SSAL Works 프로젝트의 Stage 1은 AI 검증을 통과하여 stage_gate_status가 AI Verified 상태가 된다. Project Owner는 생성된 검증 리포트를 검토하고, 8/8 Task 완료, 54개 이상 산출물 생성, 차단 요소 없음, 다음 Stage 의존성 준비 완료 등을 확인한 후 Stage 1을 승인한다. 승인이 완료되면 stage_gate_status가 Approved로 변경되고, 시스템은 Stage 2(개발 1차)로 진행한다.





【부호의 설명】
본 명세서 및 도면에서 사용되는 부호는 다음과 같다:

1) SAL 그리드 좌표계 (도 2 관련)
· 20: SAL 그리드 (3차원 좌표계)
· 21: Stage 축
· 22: Area 축
· 23: Level 축

2) SAL ID 구성 요소 (도 3 관련)
· 30: SAL ID 생성 모듈
· 31: Stage
· 32: Area
· 33: Level
· 34: Variant

3) 엔진 계층 모듈 (도 1, 4, 5 관련)
· 40: 파서 모듈
· 46: 미할당 큐 (Unassigned Queue)
· 51: 기본 정보
· 52: SAL 그리드 생성기 (Task 지시서 및 검증 지시서 생성)
· 53: 시퀀서
· 54: 배분기
· 55: SAL 그리드 완성

4) 기록 및 뷰어 시스템 (도 1, 6 관련)
· 60: SAL 그리드 기록기
· 61: 데이터베이스 시스템
· 62: 뷰어 엔진
· 63: UI 렌더링 시스템(SAL 그리드 뷰어)

5) ID 체인 관리 모듈 (도 7 관련)
· 70: SAL ID 체인 모듈
· 71: SAL ID 체인 목록
· 72: 최신 SAL ID
· 73: 체인 덧붙이기(Append)
· 74: 리졸버 (최신 ID 해석)

6) 오케스트레이션 사이클 (도 8 관련)
· 81: 계획 수립
· 82: SAL ID 생성
· 83: SAL 그리드 구축 (초기화)
· 84: Task 실행
· 85: 검증 수행
· 86: 실행 및 검증 결과 기록
· 87: Stage 검증
· 88: 리포트 생성
· 89: Stage 승인 (Stage Gate)

【산업상 이용가능성】
본 발명은 복수의 Stage와 Area에 걸쳐 장기간 수행되는 복잡한 프로젝트를 체계적으로 오케스트레이션하고 관리하는 데 필수적인 다양한 산업 분야에 폭넓게 이용될 수 있다. 대표적인 적용 사례를 제시하면 아래와 같다.

첫째, 소프트웨어 개발(Software Development) 분야에 적용된다. 복잡한 마이크로서비스 아키텍처(MSA) 환경에서 빌드, 테스트, 배포 파이프라인을 관리하는 데 있어, 각 서비스의 배포 단계를 3차원 그리드에 매핑하여 시각화함으로써 서비스 간의 의존성 충돌을 사전에 방지하고 배포 병목 구간을 신속하게 파악할 수 있다.

둘째, 대형 제조(Large-scale Manufacturing) 및 선박 건조(Shipbuilding) 분야에 적용된다. 선박이나 대형 플랜트와 같이 수만 개의 부품과 공정이 복잡하게 얽힌 제조 현장에서, 블록 조립 및 의장 작업을 3차원 좌표계로 체계화하여 관리한다. 이를 통해 공정 간의 물리적, 시간적 간섭을 시뮬레이션하여 리스크를 최소화하고, 각 부품의 품질 검사 이력을 체인으로 추적하여 제품의 신뢰도를 높인다.

셋째, 건설(Construction) 및 인프라 구축 분야에 적용된다. 고층 빌딩이나 도로, 교량 건설과 같은 대형 인프라 프로젝트에서 토목, 골조, 마감 등 시공 단계와 공구(Zone)별 작업을 입체적으로 관리한다. 이는 다수의 협력사가 투입되는 현장에서 작업 간섭을 방지하고 자재 투입 시점을 최적화하여 전체 공사 기간을 단축하는 데 기여한다.

넷째, 회계감사(Accounting Audit) 분야에 적용된다. 기업의 회계감사 수행 시, 재무제표의 각 계정 과목 및 필수 감사 절차를 그리드 상의 작업으로 정의하여 관리한다. 감사인의 수행 내역과 승인 과정이 블록체인 방식의 체인에 기록되므로 위변조가 불가능하며, 이를 통해 투명하고 신뢰할 수 있는 완벽한 감사 증적(Audit Trail)을 확보할 수 있다.

다섯째, 영화 및 드라마 제작(Media Production) 분야에 적용된다. 프리프로덕션, 프로덕션, 포스트프로덕션으로 이어지는 콘텐츠 제작 과정에서, 씬(Scene), 장소, 배우, 촬영 스케줄을 3차원적으로 구조화하여 관리한다. 이는 복잡한 촬영 일정을 효율적으로 조정하고 자원 낭비를 막아 제작비 절감 및 콘텐츠 완성도 향상에 기여한다.
【특허청구범위】

【청구항 1】
SAL 3D Grid 기반 멀티태스크 오케스트레이션 방법에 있어서,
(a) 컴퓨터 시스템이, Stage와 Area로 구성된 매트릭스 상에서 복수의 Task들을 선정하고 각 Task에 Level 및 Variant를 부여하여 인코딩한 SAL ID를 수신하되, 상기 SAL ID는 절차적 순서, 실행적 선후 관계의 의존성, 병렬성 및 인접성 정보를 구조적으로 내재하며, 정규식에 기초하여 상기 SAL ID를 파싱하고 Stage, Area, Level, Variant 구성요소를 추출하여 정규화하되, 유효하지 않은 SAL ID는 시스템 흐름을 중단하지 않고 별도로 관리하는 단계;
(b) 상기 컴퓨터 시스템이, SAL 그리드 생성기가 Task 지시서 및 검증 지시서를 생성하고, 시퀀서가 Level 충돌을 감지하여 SAL ID를 조정하며, 배분기가 Task 에이전트와 검증 에이전트를 분리하여 배정하고 필요한 도구를 배정하여 프로젝트 SAL 그리드를 구축하는 단계;
(c) 상기 컴퓨터 시스템이, 배정된 Task 에이전트가 Task 지시서에 따라 작업을 실행하여 산출물을 생성하고, 배정된 검증 에이전트가 검증 지시서에 따라 검증을 수행하는 단계;
(d) 상기 컴퓨터 시스템이, SAL 그리드 레코더를 통해 Task 실행 및 검증 수행 결과를 실시간으로 SAL 그리드에 기록하는 단계;
(e) 상기 컴퓨터 시스템이, 해당 Stage 내 전체 Task의 완료 여부, 빌드 및 테스트 통과 여부, 의존성 체인 완결성, 산출물 생성 여부, 차단 요소 존재 여부를 검증하고 검증 리포트를 자동 생성하며, Stage 승인 여부를 결정하되, 승인이 거절될 경우 Task 실행 단계로 회귀하는 피드백 루프를 포함하는 단계; 및
(f) 상기 컴퓨터 시스템이, SAL ID가 변경되면 기존 SAL ID를 삭제하지 않고 새로운 SAL ID를 생성하여 연결하는 append-only 구조의 ID 체인 목록을 관리하고, 구(Old) SAL ID 조회 요청 시 체인 목록을 추적하여 최신 SAL ID를 반환함으로써 참조 무결성을 자가 치유하는 단계;
를 포함하는 방법.

【청구항 2】
청구항 1의 방법을 수행하기 위한 SAL 3D Grid 기반 멀티태스크 오케스트레이션 시스템에 있어서,
SAL ID를 수신하여 정규식 `^S(\d{1,2})([A-Z]{2})(\d{1,2})([a-z])?$`에 기초하여 파싱하고, Stage, Area, Level, Variant 구성요소를 추출하며, Area 코드표 유효성 검사, 고유키 충돌 방지, 범위 검사를 수행하고, 정렬키를 생성하며, 유효하지 않은 SAL ID를 Unassigned Queue로 이동시키는 파서 모듈;
Task 지시서 및 검증 지시서를 생성하는 SAL 그리드 생성기 모듈;
Task 내용을 분석하여 실행 순서의 문제를 파악하고 순서를 조정하여 Level 값을 변경함으로써 SAL ID를 조정하고 변경된 SAL ID를 dependency 필드에서 참조하는 Task들의 의존성 정보를 자동으로 갱신하는 시퀀서 모듈;
Task 지시서 정보를 분석하여 해당 작업을 수행하는 Task 에이전트와 작업 결과를 검증하는 검증 에이전트를 분리하여 배정하고 필요한 도구를 배정하는 배분기 모듈;
Task 실행 및 검증 수행 결과를 파악하여 작업의 진행 상태, 수행 소요 시간, 생성된 산출물 파일 경로, 테스트 통과 여부, 빌드 결과, 검증 결과, 차단 요소, 종합 검증 결과를 실시간으로 기록하는 SAL 그리드 레코더 모듈;
SAL ID가 변경되면 기존 SAL ID를 삭제하지 않고 새로운 SAL ID를 생성하여 체인 목록에 덧붙이는 방식으로 append-only 체인을 관리하되, 추가만 가능하고 중간 삽입, 삭제, 수정이 금지되며, 외부로부터 구(Old) SAL ID에 대한 조회 요청이 수신되면 체인 목록을 추적하여 가장 마지막에 위치한 최신 SAL ID를 반환함으로써 참조 무결성을 자가 치유하는 리졸버를 포함하는 ID 체인 관리 모듈;
데이터베이스 시스템, 뷰어 엔진, UI 렌더링 시스템의 3계층 구조를 가지며, Data Loader가 대표적으로 데이터베이스와 파일 시스템을 지원하는 어댑터 인터페이스를 통해 원시 데이터를 비동기적으로 로드하고, State Parser가 로드된 데이터를 파싱하여 렌더링 가능한 상태 객체로 변환하며, 2D 카드 뷰, 3D 블록 뷰, Dashboard를 통해 프로젝트 진행 현황을 Stage별, Area별로 그룹화하여 시각화하되, Stage(X축), Area(Y축), Level(Z축)의 3차원 좌표계로 매핑하고, Dashboard가 전체 Task 수, 상태별 Task 수, Stage별 완료율을 집계하여 표시하는 SAL 그리드 뷰어 모듈; 및
해당 Stage 내 전체 Task의 완료 여부, 빌드 및 테스트 통과 여부, 의존성 체인 완결성, 산출물 생성 여부, 차단 요소 존재 여부를 검증하고 검증 리포트를 자동 생성하는 리포팅 모듈;
을 포함하는 시스템.

【청구항 3】
컴퓨터로 하여금 청구항 1의 방법을 실행하도록 하는 명령들이 기록된 비일시적 컴퓨터 판독가능 저장매체.

【청구항 4】
청구항 1에 있어서,
상기 방법은, 계획 수립, SAL ID 생성, SAL 그리드 구축, Task 실행, 검증 수행, 실행 및 검증 결과 기록, Stage 검증, 검증 리포트 생성, Stage 승인의 9단계로 구성된 순환적 오케스트레이션 사이클을 수행하되, Stage 승인 완료 후 다음 Stage에 대해 동일한 사이클을 반복하는 것을 특징으로 하는 방법.

【청구항 5】
청구항 1에 있어서,
상기 (c) 단계는, Task 실행 완료 후 검증 결과에 따라 수정이 필요한 경우 해당 Task를 재실행하는 반복 루프를 포함하며, Task 반복 실행 루프와 Stage 승인 거절 시 재실행 루프를 모두 지원하는 것을 특징으로 하는 방법.

【청구항 6】
청구항 1에 있어서,
상기 프로젝트 SAL 그리드는, 관계형 데이터베이스의 테이블 형태 또는 버전 관리 시스템의 JSON 파일 형태로 저장되되, 중앙 집중식 관리가 필요한 환경과 분산 버전 관리가 필요한 환경을 모두 지원하는 것을 특징으로 하는 방법.

【청구항 7】
청구항 1에 있어서,
상기 (a) 단계는, 파싱된 SAL ID로부터 정렬키(Sort Key)를 생성하여 Task의 실행 순서를 자동으로 결정하되, 상기 정렬키는 Stage, Area, Level, Variant 순서로 조합되어 Task 간의 의존성과 병렬성을 반영하는 것을 특징으로 하는 방법.

【청구항 8】
청구항 1에 있어서,
상기 방법은, SAL 그리드 뷰어를 통해 프로젝트 진행 현황을 Stage를 X축, Area를 Y축, Level을 Z축으로 매핑한 3차원 블록 뷰로 시각화하는 단계를 더 포함하되, 각 블록은 해당 Task의 상태에 따라 색상으로 구분되어 표시되는 것을 특징으로 하는 방법.

【청구항 9】
청구항 1에 있어서,
상기 (c) 단계는, Task를 실행하는 Task 에이전트와 검증을 수행하는 검증 에이전트를 분리하여 배정하되, 동일한 에이전트가 작성과 검증을 모두 담당하지 않도록 하여 검증의 객관성을 보장하는 것을 특징으로 하는 방법.

【청구항 10】
청구항 2에 있어서,
상기 SAL 그리드 뷰어 모듈의 Data Loader는, 대용량 프로젝트에서도 UI가 차단되지 않도록 원시 데이터를 비동기적으로 로드하고, State Parser가 로드된 데이터를 파싱하여 렌더링 가능한 상태 객체로 변환하는 것을 특징으로 하는 시스템.

【청구항 11】
청구항 1에 있어서,
상기 Unassigned Queue는, 유효하지 않은 SAL ID를 별도로 관리하여 시스템 흐름을 중단하지 않고 계속 진행할 수 있도록 하되, Unassigned Queue에 저장된 SAL ID는 수동으로 수정된 후 재파싱되어 정상 흐름으로 복귀할 수 있는 것을 특징으로 하는 방법.

【청구항 12】
청구항 1에 있어서,
상기 (a) 단계는, 정규식 `^S(\d{1,2})([A-Z]{2})(\d{1,2})([a-z])?$`에 기초하여 SAL ID를 파싱하되, Area 코드표 유효성 검사, (stage, area, level, variant) 조합의 고유키 충돌 방지, Stage 및 Level의 1~99 범위 검사를 수행하고, 유효하지 않은 SAL ID는 시스템 흐름을 중단하지 않고 Unassigned Queue로 이동시켜 별도 관리하는 것을 특징으로 하는 방법.

【청구항 13】
청구항 1에 있어서,
상기 (b) 단계의 시퀀서는, 전체 Task 지시서들의 dependencies 필드를 파싱하여 각 Task에 대한 선행 Task 목록과 후행 Task 목록을 추출하고, 선행-후행 의존성 관계와 Level 값의 크고 작음이 일치하지 않는 경우를 Level 충돌로 검출하며, 의존성 관계에 따라 후행 Task의 Level 값을 선행 Task의 Level보다 큰 값으로 자동 증가시켜 SAL ID를 조정하는 것을 특징으로 하는 방법.

【청구항 14】
청구항 1에 있어서,
상기 (c) 단계의 검증은, 검증 에이전트가 단위 테스트, 통합 테스트, 빌드 검증, 통합 검증을 순차적으로 수행하는 것을 특징으로 하는 방법.

【청구항 15】
청구항 1에 있어서,
상기 (d) 단계는, SAL 그리드 레코더가 작업의 진행 상태, 수행 소요 시간, 생성된 산출물 파일 경로, 테스트 통과 여부, 빌드 결과, 검증 결과, 차단 요소, 종합 검증 결과를 포함하는 복수의 속성을 실시간으로 기록하는 것을 특징으로 하는 방법.

【청구항 16】
청구항 1에 있어서,
상기 방법은, 상기 컴퓨터 시스템이 SAL 그리드 뷰어를 통해 프로젝트 진행 현황을 Stage별, Area별로 그룹화된 2차원 카드 뷰 및 Stage(X축), Area(Y축), Level(Z축)의 3차원 블록 뷰로 시각화하는 단계를 더 포함하되, 상기 뷰어는 데이터베이스 시스템, 뷰어 엔진, UI 렌더링 시스템의 3계층 구조를 가지며, Data Loader가 원시 데이터를 비동기적으로 로드하고, State Parser가 로드된 데이터를 파싱하여 렌더링 가능한 상태 객체로 변환하며, Dashboard가 전체 Task 수, 상태별 Task 수, Stage별 완료율을 집계하여 표시하는 것을 특징으로 하는 방법.

【요약서】

【요약】
본 발명은 프로젝트의 Stage(단계)와 Area(영역)로 구성된 매트릭스 상에서 Task(작업)를 선정하여 Level(계층) 및 Variant(병렬 분기)를 부여하고, 이들 정보를 인코딩하여 SAL ID(식별자)를 생성한다. 생성된 SAL ID는 절차적 순서와, 실행적 선후 관계의 의존성, 병렬성 및 인접성 정보를 구조적으로 내재하고 있다.

생성된 SAL ID를 파서가 파싱하여 3차원 좌표(Stage, Area, Level)를 추출하고, SAL 그리드 생성기가 Task 지시서 및 검증 지시서를 생성하며, 시퀀서가 SAL ID를 조정하고 배분기가 에이전트와 도구를 배정하여 복수의 속성으로 구성된 프로젝트 SAL 그리드를 구축한다.

이렇게 구축된 SAL 그리드를 포함하는 멀티 태스크 오케스트레이션 시스템은, 식별자를 생성하는 SAL ID 생성 모듈, SAL ID를 해석하여 정규화하는 파서 모듈, 지시서를 생성하는 SAL 그리드 생성기, Task의 내용을 분석하여 실행 순서를 조정하는 시퀀서, 작업에 필요한 리소스를 배분하는 배분기, Task 실행 및 검증 수행 결과를 기록하는 SAL 그리드 레코더, 그리고 프로젝트의 진행 상황을 시각화하는 SAL 그리드 뷰어 등으로 구성된다.

또한, 본 시스템에 따른 오케스트레이션은 Stage(단계)와 Area(영역)로 구성된 매트릭스를 활용한 계획 수립부터 시작하여, SAL ID 생성, Task 및 검증 지시서 생성, Task 실행, 검증 수행, 실행 및 검증 결과 기록, Stage 검증, 검증 리포트 생성을 거쳐 Stage 승인이 이루어지고 나서 그 다음 Stage가 똑같은 방식으로 진행되는 순환적 프로세스 형태를 갖추고 있다.

위와 같은 멀티 태스크 오케스트레이션 시스템은, 특정 프로젝트 수행에 필요한 다수의 복잡한 작업을 최적화된 방식으로 진행하고 그 과정에 대한 관리, 통제 및 검증을 자동화함으로써 효율성과 효과성을 극대화하고 결과물의 품질을 높게 만든다.

【대표도】
도 1