# 프로젝트 디렉토리 구조 관리

> **작성일**: 2025-11-18
> **카테고리**: 프로젝트 기획
> **목적**: 사용자별 다양한 프로젝트 구조를 DB 없이 관리하는 방법

---

## 📋 개요

SSALWorks는 **범용 플랫폼**으로 여러 사용자가 사용합니다.
각 사용자는 **자신만의 프로젝트 구조**를 가질 수 있습니다.

### 핵심 원칙

**1. DB에 저장하지 않음**
- 프로젝트 구조를 DB에 저장하지 않음
- 사용자 로컬 파일 시스템 사용
- Supabase 비용 절약

**2. 자동 감지**
- 사용자가 폴더 추가/삭제하면 자동 반영
- 별도 명령어 불필요
- 실시간 동기화

**3. 유연성**
- 대분류(Phase): 고정 (P1_사업계획 ~ 4_운영)
- 중분류: 사용자마다 다름
- 소분류: 사용자마다 다름

---

## 🏗️ 디렉토리 구조 규칙

### 대분류 (Phase) - 고정

```
P1_사업계획/
1_기획/
2_개발준비/
3_개발/
4_운영/
```

**특징:**
- 모든 프로젝트 공통
- 숫자로 시작 (0_, 1_, 2_, ...)
- 변경 불가

---

### 중분류 (Category) - 사용자별 자유

**사용자A 예시:**
```
1_기획/
├── 1-1_요구사항/
├── 1-2_디자인/
└── 1-3_데이터베이스/
```

**사용자B 예시:**
```
1_기획/
├── 1-1_시장조사/
├── 1-2_경쟁사분석/
├── 1-3_UI_UX/
└── 1-4_프로토타입/
```

**특징:**
- 사용자마다 다름
- 숫자-숫자 형식 (1-1_, 1-2_, ...)
- 자유롭게 추가/삭제 가능

---

### 소분류 (Subcategory) - 사용자별 자유

**예시:**
```
1_기획/
└── 1-1_요구사항/
    ├── 기능요구사항/
    ├── 비기능요구사항/
    └── 사용자시나리오/
```

**특징:**
- 사용자마다 다름
- 네이밍 자유
- 없어도 됨

---

## 🔧 기술 구현

### 1. 로컬 서버 (inbox_server.js)

**API 엔드포인트 추가:**
```
GET /project-structure?path={프로젝트경로}
```

**응답 예시:**
```json
{
  "success": true,
  "projectPath": "C:\\!SSAL_Works_Private",
  "structure": {
    "phases": [
      {
        "name": "P1_사업계획",
        "path": "C:\\!SSAL_Works_Private\\P1_사업계획",
        "categories": [
          {
            "name": "0-1_Vision_Mission",
            "path": "C:\\!SSAL_Works_Private\\P1_사업계획\\0-1_Vision_Mission",
            "subcategories": []
          }
        ]
      },
      {
        "name": "1_기획",
        "path": "C:\\!SSAL_Works_Private\\1_기획",
        "categories": [
          {
            "name": "1-1_Project_Plan",
            "path": "C:\\!SSAL_Works_Private\\1_기획\\1-1_Project_Plan",
            "subcategories": [
              {
                "name": "Business_Requirements",
                "path": "C:\\!SSAL_Works_Private\\1_기획\\1-1_Project_Plan\\Business_Requirements"
              }
            ]
          },
          {
            "name": "1-2_UI_UX_Design",
            "path": "C:\\!SSAL_Works_Private\\1_기획\\1-2_UI_UX_Design",
            "subcategories": []
          }
        ]
      }
    ]
  }
}
```

---

### 2. 스캔 함수 로직

```javascript
function scanProjectStructure(projectPath) {
  const result = { phases: [] }

  // 1. 대분류 폴더 찾기 (0_, 1_, 2_, ...)
  const phaseDirs = fs.readdirSync(projectPath)
    .filter(d => d.match(/^\d_/) && isDirectory(d))
    .sort()

  phaseDirs.forEach(phaseDir => {
    const phase = {
      name: phaseDir,
      categories: []
    }

    // 2. 중분류 폴더 찾기 (1-1_, 1-2_, ...)
    const categoryDirs = fs.readdirSync(phasePath)
      .filter(d => d.match(/^\d-\d_/) && isDirectory(d))
      .sort()

    categoryDirs.forEach(categoryDir => {
      const category = {
        name: categoryDir,
        subcategories: []
      }

      // 3. 소분류 폴더 찾기 (모든 하위 폴더)
      const subcategoryDirs = fs.readdirSync(categoryPath)
        .filter(d => isDirectory(d))
        .sort()

      category.subcategories = subcategoryDirs
      phase.categories.push(category)
    })

    result.phases.push(phase)
  })

  return result
}
```

---

### 3. 웹 대시보드에서 사용

```typescript
// Next.js 컴포넌트
'use client'

import { useEffect, useState } from 'react'

export default function ProjectStructure({ projectPath }) {
  const [structure, setStructure] = useState(null)

  // 5초마다 자동 새로고침
  useEffect(() => {
    loadStructure()
    const interval = setInterval(loadStructure, 5000)
    return () => clearInterval(interval)
  }, [projectPath])

  async function loadStructure() {
    const response = await fetch(
      `http://localhost:3030/project-structure?path=${encodeURIComponent(projectPath)}`
    )
    const data = await response.json()
    setStructure(data.structure)
  }

  if (!structure) return <div>Loading...</div>

  return (
    <div className="project-structure">
      {structure.phases.map(phase => (
        <div key={phase.name} className="phase">
          <h2>📁 {phase.name}</h2>
          {phase.categories.map(category => (
            <div key={category.name} className="category">
              <h3>└─ {category.name}</h3>
              {category.subcategories.length > 0 && (
                <ul>
                  {category.subcategories.map(sub => (
                    <li key={sub.name}>  └─ {sub.name}</li>
                  ))}
                </ul>
              )}
            </div>
          ))}
        </div>
      ))}
    </div>
  )
}
```

---

## 🎯 사용자 경험

### 시나리오 1: 프로젝트 생성

**사용자:**
```
1. 웹 대시보드 접속
2. "새 프로젝트" 버튼 클릭
3. 프로젝트명 입력
4. "생성" 클릭
```

**시스템:**
```
1. 표준 폴더 구조 자동 생성
   - P1_사업계획/
   - 1_기획/
   - 2_개발준비/
   - 3_개발/
   - 4_운영/

2. 각 대분류 아래 기본 중분류 생성
   - 1_기획/1-1_Project_Plan/
   - 1_기획/1-2_UI_UX_Design/
   - 등등

3. inbox, outbox 폴더 생성
```

---

### 시나리오 2: 폴더 커스터마이징

**사용자:**
```
1. 탐색기 열기
2. 1_기획/ 폴더 열기
3. "1-4_사용자조사" 폴더 추가
4. "1-5_경쟁사분석" 폴더 추가
```

**웹 대시보드:**
```
(5초 후 또는 즉시)
✅ 1-4_사용자조사 자동 표시
✅ 1-5_경쟁사분석 자동 표시
```

**명령어 없음! 자동 감지!**

---

### 시나리오 3: 폴더 삭제

**사용자:**
```
1. 탐색기에서 "1-3_데이터베이스" 폴더 삭제
```

**웹 대시보드:**
```
(5초 후)
❌ 1-3_데이터베이스 자동으로 사라짐
```

---

## 🚀 서버 설정 (디폴트)

### inbox_server.js에 이미 포함됨!

**설치된 API:**
```javascript
// GET /project-structure
app.get('/project-structure', (req, res) => {
  // 자동으로 디렉토리 구조 스캔
  // 사용자가 별도 설정 불필요
})

// Orders/Outbox JSON 시스템 (2025-11-18 추가)
app.get('/orders', (req, res) => {
  // Orders 폴더의 JSON 파일 목록 반환
})

app.get('/outbox', (req, res) => {
  // Outbox 폴더의 JSON 파일 목록 반환
})
```

**사용자가 할 일:**
```
❌ 없음! 자동으로 작동!
```

**서버 시작만 하면 됨:**
```bash
cd Web_ClaudeCode_Bridge
node inbox_server.js
```

### Orders/Outbox JSON 시스템 (2025-11-18 추가) ⭐

**디렉토리 구조:**
```
Human_ClaudeCode_Bridge/
├── Orders/         ← 작업 지시 JSON 파일 (사용자 → AI)
│   └── *.json
└── inbox_server.js

Web_ClaudeCode_Bridge/
├── Outbox/         ← 작업 결과 JSON 파일 (AI → 사용자)
│   └── *.json
```

**핵심 개념:**
- **Orders**: 사용자가 AI에게 작업을 지시하는 곳
- **Outbox**: AI가 완료된 작업을 보고하는 곳
- **JSON 형식**: 구조화된 데이터로 검색, 필터링, 통계 추출 가능
- **웹 연동**: 대시보드에서 실시간 확인 가능

**work_log vs Orders/Outbox:**

| 항목 | work_log (.md) | Orders/Outbox (.json) |
|------|----------------|---------------------|
| **구조화** | 비구조화 텍스트 | 구조화된 JSON |
| **검색** | 텍스트 검색만 | 필드별 쿼리 가능 |
| **통계** | 수동 추출 | 자동 추출 |
| **웹 연동** | 어려움 | 쉬움 (자동) |
| **세션 연속성** | 불완전 | 완벽 |
| **AI 기억력** | 제한적 | 100% 유지 |

**사용 예시:**

1. **작업 지시 (Orders)**
   ```json
   // Orders/task_P1BA1.json
   {
     "task_id": "P1BA1",
     "task_name": "회원가입 API 구현",
     "requirements": {...},
     "acceptance_criteria": [...]
   }
   ```

2. **AI 작업 수행**
   - Orders 자동 감지
   - 요구사항 읽기
   - 작업 수행
   - 검증 실행

3. **결과 보고 (Outbox)**
   ```json
   // Outbox/P1BA1_completion_2025-11-18.json
   {
     "task_id": "P1BA1",
     "status": "완료",
     "deliverables": {...},
     "verification_completed": {...},
     "next_steps": [...]
   }
   ```

**상세 가이드:**
- `.claude/workflows/INBOX_OUTBOX_JSON_WORKFLOW.md` - AI 에이전트용 상세 지침
- `Web_ClaudeCode_Bridge/INBOX_OUTBOX_GUIDE.md` - 사용자 가이드

---

## 📊 DB vs 파일 시스템 비교

| 항목 | DB 저장 | 파일 시스템 스캔 |
|------|---------|----------------|
| **비용** | Supabase 비용 발생 | 무료 |
| **정확성** | 불일치 가능 | 100% 정확 |
| **유연성** | 구조 변경 시 DB 업데이트 필요 | 폴더만 바꾸면 자동 반영 |
| **속도** | 네트워크 지연 (50ms) | 로컬 디스크 (5ms) |
| **복잡도** | 높음 (동기화 로직) | 낮음 (스캔만) |

**결론: 파일 시스템 압승!**

---

## 🔄 실시간 동기화 (선택)

### Phase 1: 주기적 폴링 (현재 구현)

```typescript
// 5초마다 API 호출
setInterval(() => {
  loadStructure()
}, 5000)
```

**장점:**
- 구현 간단
- 충분히 빠름

---

### Phase 2: 파일 감시 (고급)

```javascript
// inbox_server.js에 추가
const chokidar = require('chokidar')

const watcher = chokidar.watch(projectPath, {
  ignored: /node_modules/,
  persistent: true
})

watcher.on('addDir', (path) => {
  // 폴더 추가 즉시 알림
  io.emit('structure-changed', scanProjectStructure(projectPath))
})

watcher.on('unlinkDir', (path) => {
  // 폴더 삭제 즉시 알림
  io.emit('structure-changed', scanProjectStructure(projectPath))
})
```

**장점:**
- 즉시 반영 (1초 이내)
- WebSocket 사용

---

## ✅ 체크리스트

### 서버 설정
- [x] inbox_server.js에 `/project-structure` API 추가
- [x] `scanProjectStructure()` 함수 구현
- [x] 서버 시작 메시지에 API 목록 추가

### 웹 대시보드
- [ ] 프로젝트 구조 표시 컴포넌트 구현
- [ ] 5초마다 자동 새로고침
- [ ] 폴더 클릭 시 상세 정보 표시

### 사용자 가이드
- [x] 이 문서 작성
- [ ] 사용자 매뉴얼 작성

---

## 🎓 핵심 개념 정리

### 1. 진실의 원천 (Source of Truth)

**파일 시스템 = 진실**
- DB는 복사본 (불일치 가능)
- 파일 시스템은 원본 (항상 정확)

### 2. 자동 감지 vs 수동 업데이트

**자동 감지 (채택):**
```
폴더 추가 → 자동 반영
명령어 불필요
```

**수동 업데이트 (거부):**
```
폴더 추가 → "동기화" 버튼 클릭 → 반영
번거로움
```

### 3. 로컬 우선 (Local First)

**데이터는 사용자 컴퓨터에:**
- 빠름
- 안전
- 비용 없음

**DB는 최소한만:**
- 사용자 계정
- 공유 데이터
- 협업 데이터

---

## 🚨 주의사항

### 1. 네이밍 규칙 준수

**대분류:**
```
✅ P1_사업계획
❌ Phase0_Planning
```

**중분류:**
```
✅ 1-1_Project_Plan
❌ 1_1_Project_Plan
❌ 1.1_Project_Plan
```

### 2. 폴더만 인식

**파일은 무시:**
```
1_기획/
├── 1-1_Project_Plan/  ← 인식
├── README.md          ← 무시
└── notes.txt          ← 무시
```

### 3. 서버 실행 필수

**inbox_server.js가 실행 중이어야 함:**
```bash
node Web_ClaudeCode_Bridge/inbox_server.js
```

**서버 안 떠있으면:**
- 웹에서 폴더 구조 못 봄
- "서버 연결 실패" 오류

---

## 📚 참고 자료

### 관련 문서
- `PROJECT_DIRECTORY_STRUCTURE.md` - 전체 디렉토리 구조
- `PROJECT_PLAN.md` - 프로젝트 계획
- `inbox_server.js` - 서버 소스 코드

### API 문서
```
GET /project-structure?path={프로젝트경로}

요청:
  - path: 프로젝트 루트 경로 (필수)

응답:
  - success: true/false
  - projectPath: 스캔한 경로
  - structure: { phases: [...] }
```

---

## 💡 향후 개선 사항

### Phase 1 (현재)
- [x] 기본 스캔 기능
- [x] 5초 주기 자동 새로고침
- [x] 대/중/소분류 인식

### Phase 2 (계획)
- [ ] 파일 감시 (chokidar)
- [ ] WebSocket 실시간 푸시
- [ ] 1초 이내 즉시 반영

### Phase 3 (고급)
- [ ] 폴더 드래그 앤 드롭으로 순서 변경
- [ ] 웹에서 직접 폴더 생성/삭제
- [ ] 폴더 템플릿 기능

---

## ✅ 결론

**프로젝트 디렉토리 구조 관리:**

1. **DB 저장 안 함** - 파일 시스템 사용
2. **자동 감지** - 폴더만 바꾸면 자동 반영
3. **사용자별 자유** - 중/소분류 커스터마이징
4. **비용 0원** - Supabase 비용 절약
5. **정확성 100%** - 파일 = 진실

**사용자가 할 일:**
```
✅ 폴더 추가/삭제 (탐색기에서)
❌ DB 업데이트
❌ 동기화 명령어
❌ 설정 파일 수정
```

---

**작성자**: Claude Code
**버전**: 1.0
**최종 수정**: 2025-11-18
